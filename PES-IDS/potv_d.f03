!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (bugfix_servletAD) -  4 Jan 2024 17:44
!
!  Differentiation of potv in forward (tangent) mode:
!   variations   of useful results: v
!   with respect to varying inputs: xcos2 r1 r2
!   RW status of diff variables: xcos2:in v:out r1:in r2:in
SUBROUTINE POTV_D(v, vd, r1, r1d, r2, r2d, xcos2, xcos2d) BIND(c, name=&
&'potv_d')
!
!     Written by Thomas Bondo Pedersen, november 2001.
!     - minor modifications jan. 2002 (tbp).
!     - 12-C 16-O and 13-C 16-O vibr. av. included
!       may 2002 (tbp).
!
!     Driver routine for calculating the CO-Ar
!     2D, 3D, or vibrationally averaged potential
!     (including coupling matrix elements if needed).
!     Can also be used for full 3-D calculations, or
!     1-D CO calculations.
!
!     Input:
!
!        R1    - CO distance in bohr
!        R2    - distance from CO center-of-mass to Ar in bohr
!        XCOS2 - cos to the intermolecular angle
!                (angle =   0 degrees corresponds to linear CO---Ar,
!                 angle = 180 degrees corresponds to linear Ar---CO)
!
!     Output:
!
!        V - interaction energy in hartree
!
!     Details of use:
!
!        The form of the potential is based on that used by
!        Toczylowski and Cybulski, J. Chem. Phys. 112, 4604 (2000) 
!
!        Which potential parameters are used depends upon
!        the parameter IPOT transferred in the common block POTDEF
!
!        IPOT = 1 : Use the parameters of Toczylowski and Cybulski's 
!                   CCSD(T)/aug-cc-pVTZ-33221 2D surface for R1 = RE =
!                   2.132 bohr. In this case, R1 is a dummy.
!
!        IPOT = 2 : Use the parameters of the CCSD(T)/aug-cc-pVQZ-33211
!                   2D surface for R1 = RE = 2.132 bohr. In this case,
!                   R1 is a dummy.
!
!        IPOT = 3 : Use the parameters of the CCSD(T)/aug-cc-pVQZ-33211
!                   3D surface at R1. This surface is probably not
!                   trustworthy beyond the interval (this is NOT tested!)
!                      1.898 bohr <= R1 <= 2.234 bohr
!                   due to the single-reference nature of CCSD(T).
!                   Thus, intended only for 2-D calculations at
!                   a given CO distance in the above trust interval.
!
!        IPOT = 4 : Use a matrix element of the potential in the
!                   CO vibrational basis based on a Taylor expansion
!                   through order 8 of the 3D potential surface. The
!                   CO vibrational matrix elements, <IV1|(r - re)^k|IV2>
!                   for k = 0,1,2,...,8, were obtained using MOLCAS and
!                   the CO potential curve of Huxley and Murrel, J. Chem.
!                   Soc. Faraday Trans. II 79, 323 (1983) with
!                   re = 2.132 bohr.
!                   The CO vibrational states are specified through
!                   variables IV1 and IV2.
!                   The isotope numbers of C and O are stored in
!                   common ISODEF.
!
!        IPOT = 5 : Use the potential of 3 plus the CO potential
!                   of Huxley and Maurray, J. Chem. Soc. Faraday Trans.
!                   II 79, 323 (1983) with re = 2.132 bohr. For full
!                   3-D calculations.
!
!        IPOT = 6 : Use the empirical CO potential of Huxley and Murray,
!                   J. Chem. Soc. Faraday Trans. II 79, 323 (1983) with
!                   re = 2.132 bohr. For diatomic calculations.
!
!        IPOT = 7 : As 2, but with R1 = 1.898 bohr.
!
!        IPOT = 8 : As 2, but with R1 = 2.234 bohr.
!
!        IPOT = 9 : As 5, except that the intermolecular part is kept
!                   fixed at re = 2.132 bohr to mimic the usual assumption
!                   that the intermolecular dynamics is affected
!                   by the CO vibrations only through the value of the
!                   CO rotational constant.
!
!        IPOT = 10: Use a matrix element of the potential in the
!                   CO vibrational basis based on a Taylor expansion
!                   through order 8 of the 3D potential surface. The
!                   CO vibrational matrix elements, <IV1|(r - re)^k|IV2>
!                   for k = 0,1,2,...,8, were obtained using MOLCAS and
!                   the CO potential curve on the interval
!                   1.898 bohr <= r <= 2.234 bohr calculated at the
!                   CCSD(T)/aug-cc-pVQZ level with all orbitals included.
!                   re = 2.132 bohr (NOT the CCSD(T) re !!!).
!                   The CO vibrational states are specified through
!                   variables IV1 and IV2.
!                   The isotope numbers of C and O are stored in
!                   common ISODEF.
!
!     ISTAT = 1: write calculated potential point to unit LUSTAT
!                (LUSTAT MUST BE OPEN ON ENTRY!!!!)
!
!     The routine uses coordinate transformations depending on the masses
!     used for C and O. Thus, subroutine COORD_TRF2 needs the common block
!     MASS containing info for this transformation. The structure of the
!     common block is adapted to TRIATOM.
!
!
  USE ISO_C_BINDING, ONLY : c_double
  IMPLICIT NONE
  INTEGER :: iv1
  INTEGER :: iv2
  INTEGER :: lustat
  INTEGER :: ipot
  INTEGER :: istat
!
!     Common block(s) defining the potential to be calculated.
!     ========================================================
!
!
  COMMON /potdef/ ipot, iv1, iv2, istat, lustat
  INTEGER :: isoc
  INTEGER :: isoo
  COMMON /isodef/ isoc, isoo
  DOUBLE PRECISION :: d
  DOUBLE PRECISION :: dd
  DOUBLE PRECISION :: g0
  DOUBLE PRECISION :: g0d
  DOUBLE PRECISION :: g1
  DOUBLE PRECISION :: g1d
  DOUBLE PRECISION :: g2
  DOUBLE PRECISION :: g2d
  DOUBLE PRECISION :: g3
  DOUBLE PRECISION :: g3d
  DOUBLE PRECISION :: b
  DOUBLE PRECISION :: bd
!
!
!     Parameter arrays.
!     =================
!
  DIMENSION b(6), d(6), g0(6), g1(6), g2(6), g3(6)
  DIMENSION bd(6), dd(6), g0d(6), g1d(6), g2d(6), g3d(6)
!
!     Name of subroutine.
!     ===================
!
  CHARACTER(len=4) :: secnam
  PARAMETER (secnam='POTV')
  DOUBLE PRECISION :: re
  PARAMETER (re=2.132d0)
!
!     Some variables.
!     ===============
!
  DOUBLE PRECISION :: bohr
  PARAMETER (bohr=0.52917725d0)
  DOUBLE PRECISION :: autocm
  PARAMETER (autocm=219474.625d0)
  DOUBLE PRECISION :: zero
  DOUBLE PRECISION :: one
  PARAMETER (zero=0.00d0, one=1.00d0)
  DOUBLE PRECISION :: xmass
!
!     Start calculation according to IPOT.
!     ====================================
!
!     XMASS(3) is assumed to contain the masses of
!     Ar, C, and O in that order!
!     --------------------------------------------
  DIMENSION xmass(3)
  COMMON /mass/ xmass
  DOUBLE PRECISION :: r
  DOUBLE PRECISION :: rd
  DOUBLE PRECISION :: xcos
  DOUBLE PRECISION :: xcosd
  DOUBLE PRECISION :: c60
  DOUBLE PRECISION :: c60d
  DOUBLE PRECISION :: c62
  DOUBLE PRECISION :: c62d
  DOUBLE PRECISION :: c71
  DOUBLE PRECISION :: c71d
  DOUBLE PRECISION :: c73
  DOUBLE PRECISION :: c73d
  DOUBLE PRECISION :: rco
  DOUBLE PRECISION :: rcod
  DOUBLE PRECISION :: vi
  DOUBLE PRECISION :: vid
  DOUBLE PRECISION :: vco
  DOUBLE PRECISION :: vcod
  DOUBLE PRECISION :: pi
  INTRINSIC DACOS
  DOUBLE PRECISION :: todeg
  DOUBLE PRECISION :: theta2
  DOUBLE PRECISION :: theta
  DOUBLE PRECISION :: result1
  DOUBLE PRECISION :: xcos2
  DOUBLE PRECISION :: xcos2d
  DOUBLE PRECISION :: v
  DOUBLE PRECISION :: vd
  DOUBLE PRECISION :: r1
  DOUBLE PRECISION :: r1d
  DOUBLE PRECISION :: r2
  DOUBLE PRECISION :: r2d
  xmass(1) = 39.962384
  xmass(2) = 12.000000
  xmass(3) = 15.994915
  ipot = 3
!
  IF (ipot .EQ. 1) THEN
!
!        CCSD(T)/atz-33221 surface (Cybulski's) at RE = 2.132 bohr.
!        ----------------------------------------------------------
!
    rd = r2d
    r = r2
    xcosd = xcos2d
    xcos = xcos2
    CALL PARINIT(b, d, g0, g1, g2, g3, c60, c62, c71, c73)
    c73d = 0.D0
    c71d = 0.D0
    c62d = 0.D0
    c60d = 0.D0
    g3d = 0.D0
    g2d = 0.D0
    g1d = 0.D0
    g0d = 0.D0
    dd = 0.D0
    bd = 0.D0
    CALL POTCYB_D(v, vd, r, rd, xcos, xcosd, b, bd, d, dd, g0, g0d, g1, &
&           g1d, g2, g2d, g3, g3d, c60, c60d, c62, c62d, c71, c71d, c73&
&           , c73d)
!
  ELSE IF (ipot .EQ. 2) THEN
!
!        CCSD(T)/aqz-33211 surface at RE = 2.132 bohr.
!        ---------------------------------------------
!
    rco = re
    CALL PARINIT2(b, d, g0, g1, g2, g3, c60, c62, c71, c73)
    rcod = 0.D0
    CALL COORD_TRF2_D(rco, rcod, r2, r2d, xcos2, xcos2d, r, rd, xcos, &
&               xcosd)
    c73d = 0.D0
    c71d = 0.D0
    c62d = 0.D0
    c60d = 0.D0
    g3d = 0.D0
    g2d = 0.D0
    g1d = 0.D0
    g0d = 0.D0
    dd = 0.D0
    bd = 0.D0
    CALL POTCYB_D(v, vd, r, rd, xcos, xcosd, b, bd, d, dd, g0, g0d, g1, &
&           g1d, g2, g2d, g3, g3d, c60, c60d, c62, c62d, c71, c71d, c73&
&           , c73d)
!
  ELSE IF (ipot .EQ. 3) THEN
!
!        CCSD(T)/aqz-33211 surface at R1.
!        --------------------------------
!
    rcod = r1d
    rco = r1
    bd = 0.D0
    g3d = 0.D0
    g2d = 0.D0
    g1d = 0.D0
    g0d = 0.D0
    dd = 0.D0
    CALL PARINIT3_D(b, bd, d, dd, g0, g0d, g1, g1d, g2, g2d, g3, g3d, &
&             c60, c60d, c62, c62d, c71, c71d, c73, c73d, rco, rcod)
    CALL COORD_TRF2_D(rco, rcod, r2, r2d, xcos2, xcos2d, r, rd, xcos, &
&               xcosd)
    CALL POTCYB_D(v, vd, r, rd, xcos, xcosd, b, bd, d, dd, g0, g0d, g1, &
&           g1d, g2, g2d, g3, g3d, c60, c60d, c62, c62d, c71, c71d, c73&
&           , c73d)
!
  ELSE IF (ipot .EQ. 4) THEN
!
!        CO vibrationally averaged CCSD(T)/aqz-33211 surface.
!        CO vibrational states are empirical.
!        ----------------------------------------------------
!
    rcod = r1d
    rco = r1
    CALL COORD_TRF2_D(rco, rcod, r2, r2d, xcos2, xcos2d, r, rd, xcos, &
&               xcosd)
    CALL POTVIB_D(v, vd, rco, r, rd, xcos, xcosd, iv1, iv2)
!
  ELSE IF (ipot .EQ. 5) THEN
!     
!        CO empirical + 3-D CCSD(T)/aug-cc-pVQZ-33211 surface.
!        -----------------------------------------------------
!
    rcod = r1d
    rco = r1
    bd = 0.D0
    g3d = 0.D0
    g2d = 0.D0
    g1d = 0.D0
    g0d = 0.D0
    dd = 0.D0
    CALL PARINIT3_D(b, bd, d, dd, g0, g0d, g1, g1d, g2, g2d, g3, g3d, &
&             c60, c60d, c62, c62d, c71, c71d, c73, c73d, rco, rcod)
    CALL COORD_TRF2_D(rco, rcod, r2, r2d, xcos2, xcos2d, r, rd, xcos, &
&               xcosd)
    CALL POTCYB_D(vi, vid, r, rd, xcos, xcosd, b, bd, d, dd, g0, g0d, g1&
&           , g1d, g2, g2d, g3, g3d, c60, c60d, c62, c62d, c71, c71d, &
&           c73, c73d)
    CALL POTCO_D(vco, vcod, rco, rcod)
    vd = vid + vcod
    v = vi + vco
!
  ELSE IF (ipot .EQ. 6) THEN
!     
!        CO empirical.
!        -------------
!
    rcod = r2d
    rco = r2
    r = zero
    xcos = one
    CALL POTCO_D(v, vd, rco, rcod)
!
  ELSE IF (ipot .EQ. 7) THEN
!
!        CCSD(T)/aqz-33211 surface at RCO = 1.898 bohr.
!        ---------------------------------------------
!
    rco = 1.898d0
    CALL PARINIT3(b, d, g0, g1, g2, g3, c60, c62, c71, c73, rco)
    rcod = 0.D0
    CALL COORD_TRF2_D(rco, rcod, r2, r2d, xcos2, xcos2d, r, rd, xcos, &
&               xcosd)
    c73d = 0.D0
    c71d = 0.D0
    c62d = 0.D0
    c60d = 0.D0
    g3d = 0.D0
    g2d = 0.D0
    g1d = 0.D0
    g0d = 0.D0
    dd = 0.D0
    bd = 0.D0
    CALL POTCYB_D(v, vd, r, rd, xcos, xcosd, b, bd, d, dd, g0, g0d, g1, &
&           g1d, g2, g2d, g3, g3d, c60, c60d, c62, c62d, c71, c71d, c73&
&           , c73d)
!
  ELSE IF (ipot .EQ. 8) THEN
!
!        CCSD(T)/aqz-33211 surface at RCO = 2.234 bohr.
!        ---------------------------------------------
!
    rco = 2.234d0
    CALL PARINIT3(b, d, g0, g1, g2, g3, c60, c62, c71, c73, rco)
    rcod = 0.D0
    CALL COORD_TRF2_D(rco, rcod, r2, r2d, xcos2, xcos2d, r, rd, xcos, &
&               xcosd)
    c73d = 0.D0
    c71d = 0.D0
    c62d = 0.D0
    c60d = 0.D0
    g3d = 0.D0
    g2d = 0.D0
    g1d = 0.D0
    g0d = 0.D0
    dd = 0.D0
    bd = 0.D0
    CALL POTCYB_D(v, vd, r, rd, xcos, xcosd, b, bd, d, dd, g0, g0d, g1, &
&           g1d, g2, g2d, g3, g3d, c60, c60d, c62, c62d, c71, c71d, c73&
&           , c73d)
!
  ELSE IF (ipot .EQ. 9) THEN
!     
!        CO empirical + 2-D CCSD(T)/aug-cc-pVQZ-33211 surface
!                       at RCO = 2.132 bohr.
!        ----------------------------------------------------
!
    rco = re
    CALL PARINIT2(b, d, g0, g1, g2, g3, c60, c62, c71, c73)
    rcod = 0.D0
    CALL COORD_TRF2_D(rco, rcod, r2, r2d, xcos2, xcos2d, r, rd, xcos, &
&               xcosd)
    c73d = 0.D0
    c71d = 0.D0
    c62d = 0.D0
    c60d = 0.D0
    g3d = 0.D0
    g2d = 0.D0
    g1d = 0.D0
    g0d = 0.D0
    dd = 0.D0
    bd = 0.D0
    CALL POTCYB_D(vi, vid, r, rd, xcos, xcosd, b, bd, d, dd, g0, g0d, g1&
&           , g1d, g2, g2d, g3, g3d, c60, c60d, c62, c62d, c71, c71d, &
&           c73, c73d)
    CALL POTCO(vco, rco)
    vd = vid
    v = vi + vco
!
  ELSE IF (ipot .EQ. 10) THEN
!
!        CO vibrationally averaged CCSD(T)/aqz-33211 surface.
!        The CO vibrational states are from CCSD(T)/aqz.
!        ----------------------------------------------------
!
    rcod = r1d
    rco = r1
    CALL COORD_TRF2_D(rco, rcod, r2, r2d, xcos2, xcos2d, r, rd, xcos, &
&               xcosd)
    CALL POTVIB_D(v, vd, rco, r, rd, xcos, xcosd, iv1, iv2)
!
  ELSE
!
!        Undefined surface: abort.
!        -------------------------
!
    WRITE(6, '(//,5X,A,A,I6,/,5X,A)') secnam, &
&   ': Undefined potential, IPOT = ', ipot, &
&   ' - program will be aborted !!!'
    STOP
!
  END IF
!
  IF (istat .EQ. 1) THEN
    pi = DACOS(-1.00d0)
    todeg = 180.000d0/pi
    result1 = DACOS(xcos2)
    theta2 = result1*todeg
    result1 = DACOS(xcos)
    theta = result1*todeg
    WRITE(lustat, '(/,A,1X,F15.7,1X,F15.7,1X,F15.7)') 'Input  coord.:', &
&   r1*bohr, r2*bohr, theta2
    WRITE(lustat, '(A,1X,F15.7,1X,F15.7,1X,F15.7)') 'Actual coord.:', &
&   rco*bohr, r*bohr, theta
    WRITE(lustat, '(A,1X,F15.7)') 'Potential    :', v*autocm
    IF (ipot .EQ. 5 .OR. ipot .EQ. 9) WRITE(lustat, &
&                                     '(A,1X,F15.7,1X,F15.7)') &
&                                     'V(CO), VI    :', vco*autocm, vi*&
&                                     autocm
  END IF
!
  RETURN
END SUBROUTINE POTV_D

!  Differentiation of potco in forward (tangent) mode:
!   variations   of useful results: v
!   with respect to varying inputs: r
SUBROUTINE POTCO_D(v, vd, r, rd)
  IMPLICIT NONE
  DOUBLE PRECISION :: rhop
  DOUBLE PRECISION :: rhopd
  DOUBLE PRECISION :: a
!
!     Evaluate the empirical CO potential of Huxley and Murray,
!     J. Chem. Soc. Faraday Trans. II 79, 323 (1983), with
!     RE = 2.132 bohr.
!
!     Input:
!
!        R - in bohr
!
!     Output:
!
!        V - in hartree
!
!
  DIMENSION a(3), rhop(0:3)
  DIMENSION rhopd(0:3)
  DOUBLE PRECISION :: de
  PARAMETER (de=11.226d0)
  DOUBLE PRECISION :: re
  PARAMETER (re=2.132d0)
  DOUBLE PRECISION :: bohr
  PARAMETER (bohr=0.52917725d0)
!
  DOUBLE PRECISION :: autoev
  PARAMETER (autoev=27.2113834d0)
  DOUBLE PRECISION :: one
  PARAMETER (one=1.00d0)
  DOUBLE PRECISION :: rho
  DOUBLE PRECISION :: rhod
  INTEGER :: i
  DOUBLE PRECISION :: xpo
  DOUBLE PRECISION :: xpod
  INTRINSIC DEXP
  INTEGER :: ii1
  DOUBLE PRECISION :: temp
  DOUBLE PRECISION :: r
  DOUBLE PRECISION :: rd
  DOUBLE PRECISION :: v
  DOUBLE PRECISION :: vd
!
!     The next 3 lines define the potential parameters.
!     =================================================
!
  DATA a /3.897d0, 2.305d0, 1.898d0/
!
!     Calculate V in eV.
!     ==================
!
  rhod = bohr*rd
  rho = (r-re)*bohr
  v = one
  DO ii1=0,3
    rhopd(ii1) = 0.D0
  END DO
  CALL CALPOW_D(rhop, rhopd, rho, rhod, 3)
  vd = 0.D0
  DO i=1,3
    vd = vd + a(i)*rhopd(i)
    v = v + a(i)*rhop(i)
  END DO
  xpod = -(a(1)*rhopd(1))
  xpo = -(a(1)*rhop(1))
  temp = DEXP(xpo)
  vd = -(de*(temp*vd+v*DEXP(xpo)*xpod))
  v = -(de*(v*temp))
!
!     Convert V to hartree.
!     =====================
!
  vd = vd/autoev
  v = v/autoev
!
  RETURN
END SUBROUTINE POTCO_D

!  Differentiation of potcyb in forward (tangent) mode:
!   variations   of useful results: v
!   with respect to varying inputs: xcos bc g0 g1 g2 g3 c60 c62
!                r2 c71 c73 dc
SUBROUTINE POTCYB_D(v, vd, r2, r2d, xcos, xcosd, bc, bcd, dc, dcd, g0, &
& g0d, g1, g1d, g2, g2d, g3, g3d, c60, c60d, c62, c62d, c71, c71d, c73, &
& c73d)
  IMPLICIT NONE
  DOUBLE PRECISION :: bc
  DOUBLE PRECISION :: g0
  DOUBLE PRECISION :: g1
  DOUBLE PRECISION :: g2
  DOUBLE PRECISION :: g3
  DOUBLE PRECISION :: dc
!
!     Evaluate the potential form from JCP 112, 4604 (2000)
!
!        - Changes relative to this paper:
!          [they are due to B*R being negative here]
!
!           Eq. (2): D - B*R    ---> D + B*R
!           Eq. (6): In sum:  x ---> |x|
!                    In exp: -x ---> +x
!           (Tab. II: b and d parameters should be interchanged.)
!
!     Input:
!
!        R2 in bohr, XCOS (dimensionless)
!        Parameters BC, DC, etc.
!
!     Output:
!
!        V in hartree
!
!
  DIMENSION bc(6), dc(6), g0(6), g1(6), g2(6), g3(6)
  DOUBLE PRECISION :: bcd
  DOUBLE PRECISION :: g0d
  DOUBLE PRECISION :: g1d
  DOUBLE PRECISION :: g2d
  DOUBLE PRECISION :: g3d
  DOUBLE PRECISION :: dcd
  DIMENSION bcd(6), dcd(6), g0d(6), g1d(6), g2d(6), g3d(6)
  DOUBLE PRECISION :: pl
  DOUBLE PRECISION :: pld
!
  DIMENSION pl(6)
  DIMENSION pld(6)
  DOUBLE PRECISION :: xmilli
  DOUBLE PRECISION :: bohr
  PARAMETER (bohr=0.52917725d0, xmilli=1.00d-3)
!
  DOUBLE PRECISION :: r
  DOUBLE PRECISION :: rd
  DOUBLE PRECISION :: b
  DOUBLE PRECISION :: bd
  DOUBLE PRECISION :: d
  DOUBLE PRECISION :: dd
  DOUBLE PRECISION :: g
  DOUBLE PRECISION :: gd
  DOUBLE PRECISION :: br
  DOUBLE PRECISION :: brd
  DOUBLE PRECISION :: vsh
  DOUBLE PRECISION :: vshd
  INTRINSIC DEXP
  DOUBLE PRECISION :: f6
  DOUBLE PRECISION :: f6d
  DOUBLE PRECISION :: f7
  DOUBLE PRECISION :: f7d
  DOUBLE PRECISION :: rq
  DOUBLE PRECISION :: rqd
  DOUBLE PRECISION :: r6
  DOUBLE PRECISION :: r6d
  DOUBLE PRECISION :: r7
  DOUBLE PRECISION :: r7d
  DOUBLE PRECISION :: as6
  DOUBLE PRECISION :: as6d
  DOUBLE PRECISION :: as7
  DOUBLE PRECISION :: as7d
  DOUBLE PRECISION :: vas
  DOUBLE PRECISION :: vasd
  INTEGER :: ii1
  DOUBLE PRECISION :: temp
  DOUBLE PRECISION :: xcos
  DOUBLE PRECISION :: xcosd
  DOUBLE PRECISION :: v
  DOUBLE PRECISION :: vd
  DOUBLE PRECISION :: c60
  DOUBLE PRECISION :: c60d
  DOUBLE PRECISION :: c62
  DOUBLE PRECISION :: c62d
  DOUBLE PRECISION :: r2
  DOUBLE PRECISION :: r2d
  DOUBLE PRECISION :: c71
  DOUBLE PRECISION :: c71d
  DOUBLE PRECISION :: c73
  DOUBLE PRECISION :: c73d
!
!     Convert R2 to Angstrom.
!     =======================
!
  rd = bohr*r2d
  r = r2*bohr
!
!     Get the lowest Legendre functions.
!     ----------------------------------
!
  DO ii1=1,6
    pld(ii1) = 0.D0
  END DO
  CALL CYB_LEGENDRE_D(pl, pld, xcos, xcosd, 6)
!
!     Short-range part.
!     =================
!
  CALL CYB_X_D(b, bd, pl, pld, bc, bcd)
  CALL CYB_X_D(d, dd, pl, pld, dc, dcd)
  CALL CYB_G_D(g, gd, r, rd, pl, pld, g0, g0d, g1, g1d, g2, g2d, g3, g3d&
&       )
!
  brd = r*bd + b*rd
  br = b*r
  temp = DEXP(d + br)
  vshd = temp*gd + g*DEXP(d+br)*(dd+brd)
  vsh = g*temp
!
!
!     Asymptotic part.
!     ----------------
!
  CALL CYB_TT_D(f6, f6d, br, brd, 6)
  CALL CYB_TT_D(f7, f7d, br, brd, 7)
!
  rqd = 2*r*rd
  rq = r*r
  r6d = 3*rq**2*rqd
  r6 = rq*rq*rq
  r7d = r*r6d + r6*rd
  r7 = r6*r
  temp = (pl(1)*c60+pl(3)*c62)/r6
  as6d = (c60*pld(1)+pl(1)*c60d+c62*pld(3)+pl(3)*c62d-temp*r6d)/r6
  as6 = temp
  temp = (pl(2)*c71+pl(4)*c73)/r7
  as7d = (c71*pld(2)+pl(2)*c71d+c73*pld(4)+pl(4)*c73d-temp*r7d)/r7
  as7 = temp
  vasd = as6*f6d + f6*as6d + as7*f7d + f7*as7d
  vas = f6*as6 + f7*as7
!
!     Total, convert to hartree (from mEh).
!     -------------------------------------
!
  vd = vshd + vasd
  v = vsh + vas
  vd = xmilli*vd
  v = v*xmilli
!
  RETURN
END SUBROUTINE POTCYB_D

!  Differentiation of potvib in forward (tangent) mode:
!   variations   of useful results: v
!   with respect to varying inputs: xcos r2
SUBROUTINE POTVIB_D(v, vd, r1, r2, r2d, xcos, xcosd, iv1, iv2)
  IMPLICIT NONE
  INTEGER :: ipot
  INTEGER :: nordr
!
!     Evaluate the potential matrix element between CO vibrational
!     states IV1 and IV2 for the aQZ-33211 3D potential
!     (defined through IPOT = 3 below).
!
!     Input:
!
!        R1 in bohr (only needed for debugging)
!        R2 in bohr, XCOS (dimensionless)
!        IV1, IV2 = 0,1,2 represent the CO vibrational states.
!
!     Output:
!
!        V in hartree
!
  PARAMETER (nordr=8, ipot=3)
!
  DOUBLE PRECISION :: dvas
  DOUBLE PRECISION :: dvasd
  DOUBLE PRECISION :: dvsh
  DOUBLE PRECISION :: dvshd
  DIMENSION dvsh(0:nordr), dvas(0:nordr)
  DIMENSION dvshd(0:nordr), dvasd(0:nordr)
  DOUBLE PRECISION :: fact
  DIMENSION fact(0:nordr)
  DOUBLE PRECISION :: vibr
  DIMENSION vibr(0:2, 0:2, 0:nordr)
  DOUBLE PRECISION :: bohr
  PARAMETER (bohr=0.52917725d0)
!
  DOUBLE PRECISION :: re
  PARAMETER (re=2.132d0)
  DOUBLE PRECISION :: zero
  DOUBLE PRECISION :: one
  PARAMETER (zero=0.000d0, one=1.000d0)
!
  LOGICAL :: locdbg
  PARAMETER (locdbg=.false.)
!
  CHARACTER(len=6) :: secnam
  PARAMETER (secnam='POTVIB')
  DOUBLE PRECISION :: conv
  INTEGER :: k
  DOUBLE PRECISION :: fct
  INTEGER :: ii1
  INTEGER :: iv1
  INTEGER :: iv2
  DOUBLE PRECISION :: xcos
  DOUBLE PRECISION :: xcosd
  DOUBLE PRECISION :: v
  DOUBLE PRECISION :: vd
  DOUBLE PRECISION :: r1
  DOUBLE PRECISION :: r2
  DOUBLE PRECISION :: r2d
!
!     Debug: echo input.
!     ==================
!
  IF (locdbg) THEN
    WRITE(6, '(//,A,A)') secnam, ': input parameters:'
    WRITE(6, '(A,/,3F15.7)') 'R1, R2, XCOS (bohr, bohr, dimensionless):'&
&   , r1, r2, xcos
    WRITE(6, '(A,/,2I6)') 'Vibrational element calculated for states:', &
&   iv1, iv2
  END IF
!
!     Check IV1 and IV2.
!     ==================
!
  IF (((iv1 .LT. 0 .OR. iv1 .GT. 2) .OR. iv2 .LT. 0) .OR. iv2 .GT. 2) &
& THEN
    WRITE(6, '(//,5X,A,A,/,5X,A,I4,A,I4,/,5X,A)') secnam, &
&   ': State indices must be 0, 1, or 2.', 'IV1 = ', iv1, ' IV2 = ', iv2&
&   , ' - program will be aborted !!!'
    STOP
  ELSE
!
!     Get vibrational matrix elements of (r - re)^k.
!     ==============================================
!
    CALL VIBMAT(vibr, nordr)
    conv = one
    DO k=1,nordr
      conv = conv*bohr
      vibr(iv1, iv2, k) = vibr(iv1, iv2, k)*conv
    END DO
!
    IF (locdbg) THEN
      WRITE(6, '(A)') &
&     'Matrix elements of (r - re)^k: (k, element in Angstrom^k)'
      DO k=0,nordr
        WRITE(6, '(I6,2X,1P,D15.6)') k, vibr(iv1, iv2, k)
      END DO
    END IF
!
!     Calculate Taylor expansion of V through order NORDR.
!     ====================================================
!
    DO ii1=0,nordr
      dvshd(ii1) = 0.D0
    END DO
    DO ii1=0,nordr
      dvasd(ii1) = 0.D0
    END DO
    CALL VTAYLOR_D(dvsh, dvshd, dvas, dvasd, r1, r2, r2d, xcos, xcosd, &
&            nordr, ipot)
!
!     Calculate matrix element.
!     =========================
!
    CALL CALFACT(fact, nordr)
    v = zero
    vd = 0.D0
    DO k=0,nordr
      fct = one/fact(k)
      vd = vd + vibr(iv1, iv2, k)*fct*dvshd(k) + vibr(iv1, iv2, k)*fct*&
&       dvasd(k)
      v = v + dvsh(k)*vibr(iv1, iv2, k)*fct + dvas(k)*vibr(iv1, iv2, k)*&
&       fct
    END DO
!
    RETURN
  END IF
END SUBROUTINE POTVIB_D

!  Differentiation of vtaylor in forward (tangent) mode:
!   variations   of useful results: dvas dvsh
!   with respect to varying inputs: xcos2 r2
SUBROUTINE VTAYLOR_D(dvsh, dvshd, dvas, dvasd, r1, r2, r2d, xcos2, &
& xcos2d, n, ipot)
  IMPLICIT NONE
  INTEGER :: n
  DOUBLE PRECISION :: dvas
  DOUBLE PRECISION :: dvsh
!
!     Purpose: Calculate the derivatives
!
!        DVSH(k) = (d^k VSH/dR1^k)_R1=RE
!
!        DVAS(k) = (d^k VAS/dR1^k)_R1=RE
!
!        for k=0,1,2,...,N<=NMAX (NMAX defined as parameter).
!
!        NOTICE: N CANNOT BE LESS THAN 1 !!!!
!
!        The value of RE is defined implicitly by the
!        parameters, its precise value being irrelevant here.
!
!        R1 and R2 must be supplied in units of bohr, although
!        the parameters are expected to be appropriate for these
!        in Angstrom !!!
!        Unless debugging is turned on, R1 is dummy.
!
!        The derivatives are returned in units of hartree/Angstrom^k
!
!        The potential has the Cybulski-form
!        [JCP 112, 4604 (2000)]
!
!        VSH = G(R1,R2,XCOS2) * EXP[D(R1,XCOS2) + B(R1,XCOS2)*R2]
!
!        VAS = F6(B(R1,XCOS2)*R2) * C6(R1,XCOS2)/R2**6
!            + F7(B(R1,XCOS2)*R2) * C7(R1,XCOS2)/R2**7
!
!        The parameters are obtained according to IPOT,
!
!        IPOT = 3 : Get parameters from routine GETPAR3.
!
!
  DIMENSION dvsh(0:n), dvas(0:n)
  DOUBLE PRECISION :: dvasd
  DOUBLE PRECISION :: dvshd
  DIMENSION dvshd(0:n), dvasd(0:n)
  INTEGER :: nmax
  PARAMETER (nmax=50)
!
!
  CHARACTER(len=7) :: secnam
  PARAMETER (secnam='VTAYLOR')
  DOUBLE PRECISION :: gpar
!
  DIMENSION gpar(0:5, 0:3, 0:2)
  DOUBLE PRECISION :: dpar
  DOUBLE PRECISION :: bpar
  DIMENSION dpar(0:5, 0:2), bpar(0:5, 0:2)
  DOUBLE PRECISION :: c60par
  DOUBLE PRECISION :: c62par
  DIMENSION c60par(0:2), c62par(0:2)
  DOUBLE PRECISION :: c73par
  DOUBLE PRECISION :: c71par
  DIMENSION c71par(0:2), c73par(0:2)
  DOUBLE PRECISION :: d
  DOUBLE PRECISION :: dd
  DOUBLE PRECISION :: g
  DOUBLE PRECISION :: gd
  DOUBLE PRECISION :: br
  DOUBLE PRECISION :: brd
!
  DIMENSION g(0:2), d(0:2), br(0:2)
  DIMENSION gd(0:2), dd(0:2), brd(0:2)
  DOUBLE PRECISION :: c6
  DOUBLE PRECISION :: c6d
  DOUBLE PRECISION :: c7
  DOUBLE PRECISION :: c7d
  DIMENSION c6(0:2), c7(0:2)
  DIMENSION c6d(0:2), c7d(0:2)
  DOUBLE PRECISION :: xpo
  DOUBLE PRECISION :: xpod
  DOUBLE PRECISION :: dpbr
  DOUBLE PRECISION :: dpbrd
  DIMENSION xpo(0:nmax), dpbr(0:2)
  DIMENSION xpod(0:nmax), dpbrd(0:2)
  DOUBLE PRECISION :: f6
  DOUBLE PRECISION :: f6d
  DOUBLE PRECISION :: f7
  DOUBLE PRECISION :: f7d
  DIMENSION f6(0:nmax), f7(0:nmax)
  DIMENSION f6d(0:nmax), f7d(0:nmax)
  DOUBLE PRECISION :: sum
  DOUBLE PRECISION :: sumd
  DIMENSION sum(0:7, 0:nmax)
  DIMENSION sumd(0:7, 0:nmax)
  DOUBLE PRECISION :: pleg
  DOUBLE PRECISION :: plegd
  DOUBLE PRECISION :: rpower
  DOUBLE PRECISION :: rpowerd
!
  DIMENSION pleg(0:5), rpower(0:7)
  DIMENSION plegd(0:5), rpowerd(0:7)
!
  LOGICAL :: locdbg
  PARAMETER (locdbg=.false.)
  DOUBLE PRECISION :: zero
  DOUBLE PRECISION :: two
  DOUBLE PRECISION :: one
  PARAMETER (zero=0.00d0, one=1.00d0, two=2.00d0)
!
  DOUBLE PRECISION :: bohr
  PARAMETER (bohr=0.52917725d0)
  DOUBLE PRECISION :: autocm
  PARAMETER (autocm=219474.625d0)
  DOUBLE PRECISION :: xmilli
  PARAMETER (xmilli=1.00d-3)
  DOUBLE PRECISION :: r
  DOUBLE PRECISION :: rd
  INTEGER :: k
  INTEGER :: l
  INTEGER :: m
  DOUBLE PRECISION :: rho1
  DOUBLE PRECISION :: rho2
  DOUBLE PRECISION :: val1
  DOUBLE PRECISION :: val2
  DOUBLE PRECISION :: val3
  DOUBLE PRECISION :: val4
  DOUBLE PRECISION :: val5
  DOUBLE PRECISION :: xvsh
  INTRINSIC DEXP
  DOUBLE PRECISION :: tt6
  DOUBLE PRECISION :: tt7
  DOUBLE PRECISION :: xvas
  DOUBLE PRECISION :: xv
  DOUBLE PRECISION :: xsc
  INTRINSIC DACOS
  DOUBLE PRECISION :: tsh
  DOUBLE PRECISION :: tas
  DOUBLE PRECISION :: fac
  DOUBLE PRECISION :: rho
  DOUBLE PRECISION :: rhp
  INTRINSIC DFLOAT
  DOUBLE PRECISION :: scl
  DOUBLE PRECISION :: tt
  DOUBLE PRECISION :: result1
  DOUBLE PRECISION :: result2
  INTEGER :: ii1
  DOUBLE PRECISION :: temp
  DOUBLE PRECISION :: xcos2
  DOUBLE PRECISION :: xcos2d
  INTEGER :: ipot
  DOUBLE PRECISION :: r1
  DOUBLE PRECISION :: r2
  DOUBLE PRECISION :: r2d
!
!     Abort if N < 1.
!     ===============
!
  IF (n .LT. 1) THEN
    WRITE(6, '(//,5X,A,A,/,5X,A)') secnam, &
&   ' cannot handle orders less than 1 !!', ' - aborting execution'
    STOP
  ELSE IF (n .GT. nmax) THEN
    WRITE(6, '(//,5X,A,A,I6,A,/,5X,A)') secnam, &
&   ' cannot handle orders larger than ', nmax, ' !!', &
&   ' - aborting execution'
    STOP
  ELSE IF (ipot .EQ. 3) THEN
!
!     Get the parameters according to IPOT.
!     =====================================
!
    CALL GETPAR3(bpar, dpar, gpar, c60par, c62par, c71par, c73par)
!
!     Convert R2 to Angstrom.
!     =======================
!
    rd = bohr*r2d
    r = r2*bohr
!
!     Get Legendre polynomials through order 5.
!     =========================================
!
    DO ii1=0,5
      plegd(ii1) = 0.D0
    END DO
    CALL CYB_LEGENDRE_D(pleg, plegd, xcos2, xcos2d, 6)
!
!     Set up powers of R through order 7.
!     ===================================
!
    DO ii1=0,7
      rpowerd(ii1) = 0.D0
    END DO
    CALL CALPOW_D(rpower, rpowerd, r, rd, 7)
    DO ii1=0,2
      dd(ii1) = 0.D0
    END DO
    DO ii1=0,2
      gd(ii1) = 0.D0
    END DO
    DO ii1=0,2
      c6d(ii1) = 0.D0
    END DO
    DO ii1=0,2
      c7d(ii1) = 0.D0
    END DO
    DO ii1=0,2
      brd(ii1) = 0.D0
    END DO
    DO ii1=0,2
      dpbrd(ii1) = 0.D0
    END DO
!
!     Calculate 0th, 1st, and 2nd order parameter functions:
!     par = par(0) + par(1)*(r - re) + par(2)*(r - re)^2.
!     ======================================================
!
    DO k=0,2
      brd(k) = 0.D0
      br(k) = zero
      dd(k) = 0.D0
      d(k) = zero
      gd(k) = 0.D0
      g(k) = zero
      DO l=0,5
        brd(k) = brd(k) + bpar(l, k)*plegd(l)
        br(k) = br(k) + bpar(l, k)*pleg(l)
        dd(k) = dd(k) + dpar(l, k)*plegd(l)
        d(k) = d(k) + dpar(l, k)*pleg(l)
      END DO
      DO m=0,3
        DO l=0,5
          gd(k) = gd(k) + gpar(l, m, k)*(pleg(l)*rpowerd(m)+rpower(m)*&
&           plegd(l))
          g(k) = g(k) + gpar(l, m, k)*rpower(m)*pleg(l)
        END DO
      END DO
      brd(k) = r*brd(k) + br(k)*rd
      br(k) = br(k)*r
      d(k) = d(k)
      g(k) = g(k)
      dpbrd(k) = dd(k) + brd(k)
      dpbr(k) = d(k) + br(k)
      temp = (c60par(k)*pleg(0)+c62par(k)*pleg(2))/rpower(6)
      c6d(k) = (c60par(k)*plegd(0)+c62par(k)*plegd(2)-temp*rpowerd(6))/&
&       rpower(6)
      c6(k) = temp
      temp = (c71par(k)*pleg(1)+c73par(k)*pleg(3))/rpower(7)
      c7d(k) = (c71par(k)*plegd(1)+c73par(k)*plegd(3)-temp*rpowerd(7))/&
&       rpower(7)
      c7(k) = temp
    END DO
!
!     Debug: print parameters.
!     ========================
!
    IF (locdbg) THEN
      WRITE(6, '(A,A,/,A,A)') &
&     'Order:        0               1               2        ', &
&     '   Total value', &
&     '*******************************************************', &
&     '***************'
      rho1 = (r1-2.132d0)*bohr
      rho2 = rho1*rho1
      val1 = br(0) + br(1)*rho1 + br(2)*rho2
      val2 = d(0) + d(1)*rho1 + d(2)*rho2
      val3 = g(0) + g(1)*rho1 + g(2)*rho2
      val4 = c6(0) + c6(1)*rho1 + c6(2)*rho2
      val5 = c7(0) + c7(1)*rho1 + c7(2)*rho2
      WRITE(6, 1111) 'B*R  :', (br(k), k=0,2), val1
      WRITE(6, 1111) 'D    :', (d(k), k=0,2), val2
      WRITE(6, 1111) 'G    :', (g(k), k=0,2), val3
      WRITE(6, 1111) 'C6   :', (c6(k), k=0,2), val4
      WRITE(6, 1111) 'C7   :', (c7(k), k=0,2), val5
      WRITE(6, '(A,A)') &
&     '*******************************************************', &
&     '***************'
      xvsh = val3*DEXP(val2+val1)
      CALL CYB_TT(tt6, val1, 6)
      CALL CYB_TT(tt7, val1, 7)
      xvas = tt6*val4 + tt7*val5
      xv = xvsh + xvas
      xsc = xmilli*autocm
      WRITE(6, '(A)') 'RCO, R, THETA (A, A, Deg.):'
      result1 = DACOS(xcos2)
      result2 = DACOS(-1.00d0)
      WRITE(6, '(F15.7,1X,F15.7,1X,F15.7)') r1*bohr, r2*bohr, 180.00d0*&
&     result1/result2
      WRITE(6, '(A)') 'Exact potential values:  VSH, VAS, V (cm-1)'
      WRITE(6, '(F15.7,1X,F15.7,1X,F15.7)') xvsh*xsc, xvas*xsc, xv*xsc
    END IF
!
!     Calculate derivatives of exp(D+B*R) through order N.
!     ====================================================
!
    DO ii1=0,nmax
      xpod(ii1) = 0.D0
    END DO
    CALL CALXPO_D(xpo, xpod, dpbr, dpbrd, n)
!
!     Calculate DVSH through order N.
!     ===============================
!
    DO k=0,n
      dvsh(k) = zero
    END DO
    DO ii1=0,n
      dvshd(ii1) = 0.D0
    END DO
    CALL FINCON_D(dvsh, dvshd, g, gd, xpo, xpod, n)
!
!     Calculate F6 and F7 through order N.
!     ====================================
!
    DO ii1=0,nmax
      f7d(ii1) = 0.D0
    END DO
    DO ii1=0,nmax
      f6d(ii1) = 0.D0
    END DO
    CALL CYB_DTT_D(f6, f6d, f7, f7d, br, brd, sum, sumd, n)
!
!     Calculate DVAS through order N.
!     ===============================
!
    DO k=0,n
      dvas(k) = zero
    END DO
    DO ii1=0,n
      dvasd(ii1) = 0.D0
    END DO
    CALL FINCON_D(dvas, dvasd, c6, c6d, f6, f6d, n)
    CALL FINCON_D(dvas, dvasd, c7, c7d, f7, f7d, n)
!
!     Finally convert to Eh from mEh.
!     ===============================
!
    DO k=0,n
      dvshd(k) = xmilli*dvshd(k)
      dvsh(k) = dvsh(k)*xmilli
      dvasd(k) = xmilli*dvasd(k)
      dvas(k) = dvas(k)*xmilli
    END DO
!
!     Debug: Print energies.
!     ======================
!
    IF (locdbg) THEN
      tsh = dvsh(0)
      tas = dvas(0)
      fac = one
      rho = (r1-2.132d0)*bohr
      rhp = one
      DO k=1,n
        fac = fac*DFLOAT(k)
        rhp = rhp*rho
        scl = rhp/fac
        tsh = tsh + dvsh(k)*scl
        tas = tas + dvas(k)*scl
      END DO
      tt = tsh + tas
      WRITE(6, '(A)') 'Taylor potential values:  VSH, VAS, V (cm-1)'
      WRITE(6, '(F15.7,1X,F15.7,1X,F15.7,//)') tsh*autocm, tas*autocm, &
&     tt*autocm
    END IF
!
    RETURN
  ELSE
    WRITE(6, '(//,5X,A,I9,/,5X,A,A)') &
&   'Parameters not defined by IPOT = ', ipot, &
&   ' - aborting execution in subroutine ', secnam
    STOP
  END IF
 1111 FORMAT(a6,1x,f15.7,1x,f15.7,1x,f15.7,1x,f15.7)
END SUBROUTINE VTAYLOR_D

!  Differentiation of cyb_x in forward (tangent) mode:
!   variations   of useful results: x
!   with respect to varying inputs: xc pl
SUBROUTINE CYB_X_D(x, xd, pl, pld, xc, xcd)
  IMPLICIT NONE
  DOUBLE PRECISION :: xc
  DOUBLE PRECISION :: pl
!
!     Evaluate the sum:
!
!        X = sum_(i=1,6) XC(i)*PL(i)
!
!
  DIMENSION pl(6), xc(6)
  DOUBLE PRECISION :: xcd
  DOUBLE PRECISION :: pld
  DIMENSION pld(6), xcd(6)
  DOUBLE PRECISION :: zero
  PARAMETER (zero=0.00d0)
!
  INTEGER :: i
  DOUBLE PRECISION :: x
  DOUBLE PRECISION :: xd
!
  x = zero
  xd = 0.D0
  DO i=1,6
    xd = xd + pl(i)*xcd(i) + xc(i)*pld(i)
    x = x + xc(i)*pl(i)
  END DO
!
  RETURN
END SUBROUTINE CYB_X_D

!  Differentiation of cyb_g in forward (tangent) mode:
!   variations   of useful results: g
!   with respect to varying inputs: r g0 g1 g2 g3 pl
SUBROUTINE CYB_G_D(g, gd, r, rd, pl, pld, g0, g0d, g1, g1d, g2, g2d, g3&
& , g3d)
  IMPLICIT NONE
  DOUBLE PRECISION :: g0
  DOUBLE PRECISION :: g1
  DOUBLE PRECISION :: g2
  DOUBLE PRECISION :: g3
  DOUBLE PRECISION :: pl
!
!     Evaluate the sum:
!
!        G = sum_(i=1,6) [ G0(i)     + G1(i)*R
!                        + G2(i)*R*R + G3(i)*R*R*R]
!                      * PL(i)
!
!
  DIMENSION pl(6), g0(6), g1(6), g2(6), g3(6)
  DOUBLE PRECISION :: g0d
  DOUBLE PRECISION :: g1d
  DOUBLE PRECISION :: g2d
  DOUBLE PRECISION :: g3d
  DOUBLE PRECISION :: pld
  DIMENSION pld(6), g0d(6), g1d(6), g2d(6), g3d(6)
  DOUBLE PRECISION :: zero
  PARAMETER (zero=0.00d0)
!
  DOUBLE PRECISION :: r2
  DOUBLE PRECISION :: r2d
  DOUBLE PRECISION :: r3
  DOUBLE PRECISION :: r3d
  INTEGER :: i
  DOUBLE PRECISION :: fac
  DOUBLE PRECISION :: facd
  DOUBLE PRECISION :: g
  DOUBLE PRECISION :: gd
  DOUBLE PRECISION :: r
  DOUBLE PRECISION :: rd
!
  r2d = 2*r*rd
  r2 = r*r
  r3d = r*r2d + r2*rd
  r3 = r2*r
  g = zero
  gd = 0.D0
  DO i=1,6
    facd = g0d(i) + r*g1d(i) + g1(i)*rd + r2*g2d(i) + g2(i)*r2d + r3*g3d&
&     (i) + g3(i)*r3d
    fac = g0(i) + g1(i)*r + g2(i)*r2 + g3(i)*r3
    gd = gd + pl(i)*facd + fac*pld(i)
    g = g + fac*pl(i)
  END DO
!
  RETURN
END SUBROUTINE CYB_G_D

!  Differentiation of cyb_tt in forward (tangent) mode:
!   variations   of useful results: x fn
!   with respect to varying inputs: x
SUBROUTINE CYB_TT_D(fn, fnd, x, xd, n)
  IMPLICIT NONE
  DOUBLE PRECISION :: zero
  DOUBLE PRECISION :: one
  PARAMETER (zero=0.00d0, one=1.00d0)
!
!     Evaluate the Tang-Toennis function:
!
!        FN = 1 - exp(X) sum_(k=1,N) |X|^k/k!
!
  DOUBLE PRECISION :: xsav
  DOUBLE PRECISION :: xsavd
  INTRINSIC DABS
  DOUBLE PRECISION :: dcoun
  DOUBLE PRECISION :: facn
  DOUBLE PRECISION :: xn
  DOUBLE PRECISION :: xnd
  DOUBLE PRECISION :: sum
  DOUBLE PRECISION :: sumd
  INTEGER :: i
  INTRINSIC DEXP
  DOUBLE PRECISION :: temp
  INTEGER :: n
  DOUBLE PRECISION :: x
  DOUBLE PRECISION :: xd
  DOUBLE PRECISION :: fn
  DOUBLE PRECISION :: fnd
!
  xsavd = xd
  xsav = x
  IF (xsav .GE. 0.) THEN
    xd = xsavd
    x = xsav
  ELSE
    xd = -xsavd
    x = -xsav
  END IF
!
  dcoun = zero
  facn = one
  xn = one
  sum = one
  xnd = 0.D0
  sumd = 0.D0
  DO i=1,n
    dcoun = dcoun + one
    facn = facn*dcoun
    xnd = x*xnd + xn*xd
    xn = xn*x
    sumd = sumd + xnd/facn
    sum = sum + xn/facn
  END DO
!
  xd = xsavd
  x = xsav
  temp = DEXP(x)
  fnd = -(sum*DEXP(x)*xd+temp*sumd)
  fn = one - temp*sum
!
  RETURN
END SUBROUTINE CYB_TT_D

!  Differentiation of cyb_legendre in forward (tangent) mode:
!   variations   of useful results: pl
!   with respect to varying inputs: x
SUBROUTINE CYB_LEGENDRE_D(pl, pld, x, xd, n)
  IMPLICIT NONE
!  INCLUDE 'DIFFSIZES.inc'
!  Hint: ISIZE1OFpl should be the size of dimension 1 of array pl
  DOUBLE PRECISION :: pl
!
!     Calculate (recursively) the Legendre polymials from
!     order 0 to N-1 for a given value of their argument
!     -1 <= X <= 1 (THIS IS NOT TESTED !).
!
!     Store in PL(i=1,N), N >= 1.
!
!     Note: the Legendre polynomials are NOT normalized.
!
!
  DIMENSION pl(*)
  DOUBLE PRECISION :: pld
  DIMENSION pld(*)
  DOUBLE PRECISION :: zero
  DOUBLE PRECISION :: two
  DOUBLE PRECISION :: one
  PARAMETER (zero=0.00d0, one=1.00d0, two=2.00d0)
!
  DOUBLE PRECISION :: dn
  INTEGER :: i
  INTEGER :: ii1
  INTEGER :: n
  DOUBLE PRECISION :: x
  DOUBLE PRECISION :: xd
!
!     Check N.
!     --------
!
  IF (n .LE. 0) THEN
    DO ii1=1,n
      pld(ii1) = 0.D0
    END DO
    RETURN
  ELSE
!
!     0th order = 1 (constant)
!     ------------------------
!
    pl(1) = one
    IF (n .EQ. 1) THEN
      DO ii1=1,n
        pld(ii1) = 0.D0
      END DO
    ELSE
!
!     1st order = X
!     -------------
!
      DO ii1=1,n
        pld(ii1) = 0.D0
      END DO
      pld(2) = xd
      pl(2) = x
!
!     Higher orders recursively
!     -------------------------
!
      dn = one
      DO i=3,n
        dn = dn + one
        pld(i) = (two*dn-one)*(pl(i-1)*xd+x*pld(i-1)) - (dn-one)*pld(i-2&
&         )
        pl(i) = (two*dn-one)*x*pl(i-1) - (dn-one)*pl(i-2)
        pld(i) = pld(i)/dn
        pl(i) = pl(i)/dn
      END DO
    END IF
!
    RETURN
  END IF
END SUBROUTINE CYB_LEGENDRE_D

!  Differentiation of coord_trf2 in forward (tangent) mode:
!   variations   of useful results: r2p xcosp
!   with respect to varying inputs: xcos r1 r2
SUBROUTINE COORD_TRF2_D(r1, r1d, r2, r2d, xcos, xcosd, r2p, r2pd, xcosp&
& , xcospd)
  IMPLICIT NONE
  DOUBLE PRECISION :: xmass
  DOUBLE PRECISION :: g1
  DOUBLE PRECISION :: g2
!
!     PURPOSE:
!     ========
!              Transform the internal coordinates
!              R1,R2,XCOS to coordinates appropriate
!              for the potential energy evaluation,
!              returned in R2P,XCOSP (R1 is unchanged).
!
!     NOTES:
!     ======
!           1) The routine gets the triatom masses from
!              COMMON /MASS/
!           2) It is assumed that the coordinate system
!              is defined such that Theta = 0 Degr.
!              corresponds to the linear Ar---O=C.
!
!
!     XMASS(3) is assumed to contain the masses of
!     Ar, C, and O in that order!
!     --------------------------------------------
!
  COMMON /mass/ xmass(3), g1, g2
  DOUBLE PRECISION :: xmo
  DOUBLE PRECISION :: xmc
  PARAMETER (xmo=15.9994d0, xmc=12.0112d0)
!
!     These are the masses used in the CO-Ar calculations
!     for the electronic interaction energy, and hence
!     the ones that POTV refers to.
!     ---------------------------------------------------
!
  DOUBLE PRECISION :: zero
  DOUBLE PRECISION :: xmone
  DOUBLE PRECISION :: half
  PARAMETER (xmone=-1.00d0, zero=0.00d0, half=0.50d0)
!
!     Some parameters.
!     ----------------
!
  DOUBLE PRECISION :: tol
  PARAMETER (tol=1.00d-15)
  DOUBLE PRECISION :: pihf
  INTRINSIC DACOS
  DOUBLE PRECISION :: theta
  DOUBLE PRECISION :: thetad
  DOUBLE PRECISION :: gamma
  DOUBLE PRECISION :: gammad
  DOUBLE PRECISION :: xar
  DOUBLE PRECISION :: xard
  INTRINSIC DCOS
  DOUBLE PRECISION :: yar
  DOUBLE PRECISION :: yard
  INTRINSIC DSIN
  DOUBLE PRECISION :: dnom
  DOUBLE PRECISION :: ycm
  DOUBLE PRECISION :: ycmd
  DOUBLE PRECISION :: yarp
  DOUBLE PRECISION :: yarpd
  INTRINSIC DATAN2
  INTRINSIC DSQRT
  DOUBLE PRECISION :: result1
  DOUBLE PRECISION :: arg1
  DOUBLE PRECISION :: arg1d
  DOUBLE PRECISION :: temp
  DOUBLE PRECISION :: xcos
  DOUBLE PRECISION :: xcosd
  DOUBLE PRECISION :: r2p
  DOUBLE PRECISION :: r2pd
  DOUBLE PRECISION :: xcosp
  DOUBLE PRECISION :: xcospd
  DOUBLE PRECISION :: r1
  DOUBLE PRECISION :: r1d
  DOUBLE PRECISION :: r2
  DOUBLE PRECISION :: r2d
!
!     Calculate pi/2.
!     ---------------
!
  result1 = DACOS(xmone)
  pihf = half*result1
!
!     Calculate Cartesian coordinates of Ar.
!     --------------------------------------
!
  IF (xcos .EQ. 1.0 .OR. xcos .EQ. (-1.0)) THEN
    thetad = 0.D0
  ELSE
    thetad = -(xcosd/SQRT(1.D0-xcos**2))
  END IF
  theta = DACOS(xcos)
  gammad = -thetad
  gamma = pihf - theta
!
  temp = DCOS(gamma)
  xard = temp*r2d - r2*DSIN(gamma)*gammad
  xar = r2*temp
  temp = DSIN(gamma)
  yard = temp*r2d + r2*DCOS(gamma)*gammad
  yar = r2*temp
!
!     Calculate center of mass of CO using XMC and XMO.
!     -------------------------------------------------
!
  dnom = (xmc+xmo)*(xmass(2)+xmass(3))
!
  temp = xmass(2)*xmo - xmc*xmass(3)
  ycmd = temp*r1d/dnom
  ycm = temp*(r1/dnom)
!
!     Translate origin to YCM.
!     ------------------------
!
  yarpd = yard - ycmd
  yarp = yar - ycm
!
!     Calculate new coordinates.
!     --------------------------
!
  gammad = xar*yarpd/(yarp**2+xar**2) - yarp*xard/(yarp**2+xar**2)
  gamma = DATAN2(yarp, xar)
  thetad = -gammad
  theta = pihf - gamma
!
  arg1d = 2*xar*xard + 2*yarp*yarpd
  arg1 = xar*xar + yarp*yarp
  temp = DSQRT(arg1)
  IF (arg1 .EQ. 0.0) THEN
    r2pd = 0.D0
  ELSE
    r2pd = arg1d/(2.D0*DSQRT(arg1))
  END IF
  r2p = temp
  xcospd = -(DSIN(theta)*thetad)
  xcosp = DCOS(theta)
!
  RETURN
END SUBROUTINE COORD_TRF2_D

!  Differentiation of cyb_dtt in forward (tangent) mode:
!   variations   of useful results: f6 f7
!   with respect to varying inputs: br
SUBROUTINE CYB_DTT_D(f6, f6d, f7, f7d, br, brd, sum, sumd, n)
  IMPLICIT NONE
  INTEGER :: n
  DOUBLE PRECISION :: f6
  DOUBLE PRECISION :: f7
!
!     Purpose: Calculate the derivatives of the Tang-Toennis
!              damping functions.
!
!     NOTE: N MUST BE AT LEAST 1. (NOT TESTED!)
!
  DIMENSION f6(0:n), f7(0:n)
  DOUBLE PRECISION :: f6d
  DOUBLE PRECISION :: f7d
  DIMENSION f6d(0:n), f7d(0:n)
  DOUBLE PRECISION :: br
  DIMENSION br(0:2)
  DOUBLE PRECISION :: brd
  DIMENSION brd(0:2)
  DOUBLE PRECISION :: sum
  DIMENSION sum(0:7, 0:n)
  DOUBLE PRECISION :: sumd
  DIMENSION sumd(0:7, 0:n)
  DOUBLE PRECISION :: brpow
  DOUBLE PRECISION :: brpowd
  DOUBLE PRECISION :: fact
  DIMENSION brpow(0:7), fact(0:7)
  DIMENSION brpowd(0:7)
  DOUBLE PRECISION :: zero
  DOUBLE PRECISION :: two
  DOUBLE PRECISION :: one
  PARAMETER (zero=0.00d0, one=1.00d0, two=2.00d0)
  INTRINSIC DEXP
  INTEGER :: j
  INTEGER :: k
  DOUBLE PRECISION :: scalbr2
  DOUBLE PRECISION :: scalbr2d
  INTRINSIC DFLOAT
  INTEGER :: ii1
  INTEGER :: ii2
  DOUBLE PRECISION :: temp
  DOUBLE PRECISION :: temp0
!
!     Calculate powers of BR(0) and the factorial.
!     ============================================
!
  DO ii1=0,7
    brpowd(ii1) = 0.D0
  END DO
  CALL CALPOW_D(brpow, brpowd, br(0), brd(0), 7)
  CALL CALFACT(fact, 7)
!
!     Calculate 0th order sums.
!     =========================
!
  DO ii1=0,n
    DO ii2=0,7
      sumd(ii2, ii1) = 0.D0
    END DO
  END DO
  sumd(0, 0) = DEXP(br(0))*brd(0)
  sum(0, 0) = DEXP(br(0))
  DO j=1,7
    sumd(j, 0) = (sum(0, 0)*brpowd(j)+brpow(j)*sumd(0, 0))/fact(j)
    sum(j, 0) = brpow(j)*sum(0, 0)/fact(j)
  END DO
  DO j=1,7,2
    sumd(j, 0) = -sumd(j, 0)
    sum(j, 0) = -sum(j, 0)
  END DO
!
!     Calculate 1st order sums.
!     =========================
!
  sumd(0, 1) = sum(0, 0)*brd(1) + br(1)*sumd(0, 0)
  sum(0, 1) = br(1)*sum(0, 0)
  DO j=1,7
    temp = sum(j, 0) - sum(j-1, 0)
    sumd(j, 1) = temp*brd(1) + br(1)*(sumd(j, 0)-sumd(j-1, 0))
    sum(j, 1) = br(1)*temp
  END DO
!
!     Calculate sums through order N.
!     ===============================
!
  DO k=2,n
    temp = DFLOAT(k - 1)
    scalbr2d = temp*two*brd(2)
    scalbr2 = temp*(two*br(2))
    sumd(0, k) = sum(0, k-2)*scalbr2d + scalbr2*sumd(0, k-2) + sum(0, k-&
&     1)*brd(1) + br(1)*sumd(0, k-1)
    sum(0, k) = scalbr2*sum(0, k-2) + br(1)*sum(0, k-1)
    DO j=1,7
      temp = sum(j, k-2) - sum(j-1, k-2)
      temp0 = sum(j, k-1) - sum(j-1, k-1)
      sumd(j, k) = temp*scalbr2d + scalbr2*(sumd(j, k-2)-sumd(j-1, k-2))&
&       + temp0*brd(1) + br(1)*(sumd(j, k-1)-sumd(j-1, k-1))
      sum(j, k) = scalbr2*temp + br(1)*temp0
    END DO
  END DO
!
!     Calculate the Tang-Toennis derivatives.
!     =======================================
!
  f6(0) = one
  DO k=1,n
    f6(k) = zero
  END DO
  DO ii1=0,n
    f6d(ii1) = 0.D0
  END DO
  DO ii1=0,n
    f7d(ii1) = 0.D0
  END DO
  DO k=0,n
    DO j=0,6
      f6d(k) = f6d(k) - sumd(j, k)
      f6(k) = f6(k) - sum(j, k)
    END DO
    f7d(k) = f6d(k) - sumd(7, k)
    f7(k) = f6(k) - sum(7, k)
  END DO
!
  RETURN
END SUBROUTINE CYB_DTT_D

!  Differentiation of fincon in forward (tangent) mode:
!   variations   of useful results: dv
!   with respect to varying inputs: f1 f2 dv
SUBROUTINE FINCON_D(dv, dvd, f1, f1d, f2, f2d, n)
  IMPLICIT NONE
  INTEGER :: n
  DOUBLE PRECISION :: f1
  DOUBLE PRECISION :: f2
  DOUBLE PRECISION :: dv
!
!     Purpose: accumulate the final contributions to the potential derivatives:
!
!        DV(k) = DV(k)
!              + F1(0) * F2(k)
!              + k * F1(1) * F2(k-1)
!              + k*(k-1) * F1(2) * F2(k-2)
!
!     for k = 0,1,2,...,N. N must be at least 1 (not tested).
!
  DIMENSION dv(0:n), f1(0:2), f2(0:n)
  DOUBLE PRECISION :: f1d
  DOUBLE PRECISION :: f2d
  DOUBLE PRECISION :: dvd
  DIMENSION dvd(0:n), f1d(0:2), f2d(0:n)
  DOUBLE PRECISION :: scal
  DIMENSION scal(0:2)
  DOUBLE PRECISION :: one
  PARAMETER (one=1.00d0)
  INTEGER :: k
  INTRINSIC DFLOAT
  INTEGER :: m
!
  dvd(0) = dvd(0) + f2(0)*f1d(0) + f1(0)*f2d(0)
  dv(0) = dv(0) + f1(0)*f2(0)
  dvd(1) = dvd(1) + f2(1)*f1d(0) + f1(0)*f2d(1) + f2(0)*f1d(1) + f1(1)*&
&   f2d(0)
  dv(1) = dv(1) + f1(0)*f2(1) + f1(1)*f2(0)
  scal(0) = one
  DO k=2,n
    scal(1) = DFLOAT(k)
    scal(2) = DFLOAT(k*(k-1))
    DO m=0,2
      dvd(k) = dvd(k) + scal(m)*(f2(k-m)*f1d(m)+f1(m)*f2d(k-m))
      dv(k) = dv(k) + scal(m)*f1(m)*f2(k-m)
    END DO
  END DO
!
  RETURN
END SUBROUTINE FINCON_D

!  Differentiation of calxpo in forward (tangent) mode:
!   variations   of useful results: res
!   with respect to varying inputs: fn
SUBROUTINE CALXPO_D(res, resd, fn, fnd, n)
  IMPLICIT NONE
  INTEGER :: n
  DOUBLE PRECISION :: res
  DOUBLE PRECISION :: fn
!
!     Purpose: Calculate derivatives of the exponential function,
!              given the derivatives of the exponent through order
!              2,
!
!              F = FN(0) + FN(1)*RHO + FN(2)*RHO^2
!
!              where RHO = (r - re).
!
!     NOTE: N MUST BE AT LEAST 1 (NOT TESTED!!!)
!
  DIMENSION res(0:n), fn(0:2)
  DOUBLE PRECISION :: resd
  DOUBLE PRECISION :: fnd
  DIMENSION resd(0:n), fnd(0:2)
  DOUBLE PRECISION :: two
  PARAMETER (two=2.00d0)
  INTRINSIC DEXP
  INTEGER :: k
  DOUBLE PRECISION :: scal
  INTRINSIC DFLOAT
  INTEGER :: ii1
!
  DO ii1=0,n
    resd(ii1) = 0.D0
  END DO
  resd(0) = DEXP(fn(0))*fnd(0)
  res(0) = DEXP(fn(0))
  resd(1) = res(0)*fnd(1) + fn(1)*resd(0)
  res(1) = fn(1)*res(0)
  DO k=2,n
    scal = two*DFLOAT(k-1)
    resd(k) = scal*(res(k-2)*fnd(2)+fn(2)*resd(k-2)) + res(k-1)*fnd(1) +&
&     fn(1)*resd(k-1)
    res(k) = scal*fn(2)*res(k-2) + fn(1)*res(k-1)
  END DO
!
  RETURN
END SUBROUTINE CALXPO_D

!  Differentiation of calpow in forward (tangent) mode:
!   variations   of useful results: xtok
!   with respect to varying inputs: x
SUBROUTINE CALPOW_D(xtok, xtokd, x, xd, n)
  IMPLICIT NONE
  INTEGER :: n
  DOUBLE PRECISION :: xtok
!
!     Purpose: Calculate powers of X
!
!        XTOK(k) = X**k
!
!        for k=0,1,2,...,N
!
  DIMENSION xtok(0:n)
  DOUBLE PRECISION :: xtokd
  DIMENSION xtokd(0:n)
  DOUBLE PRECISION :: one
  PARAMETER (one=1.00d0)
  INTEGER :: k
  INTEGER :: ii1
  DOUBLE PRECISION :: x
  DOUBLE PRECISION :: xd
!
  IF (n .LT. 0) THEN
    DO ii1=0,n
      xtokd(ii1) = 0.D0
    END DO
    RETURN
  ELSE
!
    xtok(0) = one
    DO ii1=0,n
      xtokd(ii1) = 0.D0
    END DO
    DO k=1,n
      xtokd(k) = x*xtokd(k-1) + xtok(k-1)*xd
      xtok(k) = xtok(k-1)*x
    END DO
!
    RETURN
  END IF
END SUBROUTINE CALPOW_D

!  Differentiation of parinit3 in forward (tangent) mode:
!   variations   of useful results: bc g0 g1 g2 g3 c60 c62 c71
!                c73 dc
!   with respect to varying inputs: rco
SUBROUTINE PARINIT3_D(bc, bcd, dc, dcd, g0, g0d, g1, g1d, g2, g2d, g3, &
& g3d, c60, c60d, c62, c62d, c71, c71d, c73, c73d, rco, rcod)
  IMPLICIT NONE
  DOUBLE PRECISION :: bc
  DOUBLE PRECISION :: g0
  DOUBLE PRECISION :: dc
!
!     Our "full" aug-cc-pVQZ-33211 surface.
!     Parameters are calculated for a given CO distance, RCO (in bohr).
!
!
  DIMENSION bc(6), dc(6), g0(6)
  DOUBLE PRECISION :: bcd
  DOUBLE PRECISION :: g0d
  DOUBLE PRECISION :: dcd
  DIMENSION bcd(6), dcd(6), g0d(6)
  DOUBLE PRECISION :: g1
  DOUBLE PRECISION :: g2
  DOUBLE PRECISION :: g3
  DIMENSION g1(6), g2(6), g3(6)
  DOUBLE PRECISION :: g1d
  DOUBLE PRECISION :: g2d
  DOUBLE PRECISION :: g3d
  DIMENSION g1d(6), g2d(6), g3d(6)
  DOUBLE PRECISION :: bcpar
  DOUBLE PRECISION :: dcpar
  DOUBLE PRECISION :: g0par
!
  DIMENSION bcpar(6, 3), dcpar(6, 3), g0par(6, 3)
  DOUBLE PRECISION :: g3par
  DOUBLE PRECISION :: g2par
  DOUBLE PRECISION :: g1par
  DIMENSION g1par(6, 3), g2par(6, 3), g3par(6, 3)
  DOUBLE PRECISION :: c60par
  DOUBLE PRECISION :: c62par
  DIMENSION c60par(3), c62par(3)
  DOUBLE PRECISION :: c73par
  DOUBLE PRECISION :: c71par
  DIMENSION c71par(3), c73par(3)
  DOUBLE PRECISION :: rd
  DOUBLE PRECISION :: rdd
  DIMENSION rd(3)
  DIMENSION rdd(3)
  DOUBLE PRECISION :: zero
  DOUBLE PRECISION :: one
  PARAMETER (zero=0.00d0, one=1.00d0)
!
  DOUBLE PRECISION :: bohr
  PARAMETER (bohr=0.52917725d0)
  DOUBLE PRECISION :: re
  PARAMETER (re=2.13200000d0)
  DOUBLE PRECISION :: diff
  DOUBLE PRECISION :: diffd
  INTEGER :: i
  INTEGER :: j
  INTEGER :: ii1
  DOUBLE PRECISION :: rco
  DOUBLE PRECISION :: rcod
  DOUBLE PRECISION :: c60
  DOUBLE PRECISION :: c60d
  DOUBLE PRECISION :: c62
  DOUBLE PRECISION :: c62d
  DOUBLE PRECISION :: c71
  DOUBLE PRECISION :: c71d
  DOUBLE PRECISION :: c73
  DOUBLE PRECISION :: c73d
!
  bcpar(1, 1) = -2.773531400530731d0
  bcpar(2, 1) = 0.355978611060635d0
  bcpar(3, 1) = -0.038461094313790d0
  bcpar(4, 1) = -0.065597122410946d0
  bcpar(5, 1) = -0.017415924916096d0
  bcpar(6, 1) = 0.009165061618361d0
  bcpar(1, 2) = 0.383748086062260d0
  bcpar(2, 2) = -0.267512471179551d0
  bcpar(3, 2) = 0.237733994757126d0
  bcpar(4, 2) = -0.466599098913902d0
  bcpar(5, 2) = 0.222943449032861d0
  bcpar(6, 2) = -0.019012147801577d0
  bcpar(1, 3) = 4.896202058362745d0
  bcpar(2, 3) = -9.446664416716875d0
  bcpar(3, 3) = -9.207034029053412d0
  bcpar(4, 3) = 6.011576154886567d0
  bcpar(5, 3) = -0.191562479666016d0
  bcpar(6, 3) = -0.365735693068647d0
!
  dcpar(1, 1) = 12.447246080504405d0
  dcpar(2, 1) = -2.612275572240643d0
  dcpar(3, 1) = 0.622683086317908d0
  dcpar(4, 1) = 0.252752167976621d0
  dcpar(5, 1) = 0.090218496365782d0
  dcpar(6, 1) = -0.048238070953660d0
  dcpar(1, 2) = 1.837823678601632d0
  dcpar(2, 2) = -1.236773331233324d0
  dcpar(3, 2) = -0.342754115413572d0
  dcpar(4, 2) = 1.438028441494077d0
  dcpar(5, 2) = -0.369337751726034d0
  dcpar(6, 2) = -0.081322869855238d0
  dcpar(1, 3) = -24.074189169057551d0
  dcpar(2, 3) = 32.523132561232011d0
  dcpar(3, 3) = 27.834718735481708d0
  dcpar(4, 3) = -25.905392215443936d0
  dcpar(5, 3) = 4.031779135514781d0
  dcpar(6, 3) = 0.487956040833263d0
!
  g0par(1, 1) = 1.339631498881794d0
  g0par(2, 1) = 2.948722284496854d0
  g0par(3, 1) = 2.031907693472959d0
  g0par(4, 1) = 0.696650687381108d0
  g0par(5, 1) = 0.121157437425799d0
  g0par(6, 1) = -0.058540074115915d0
  g0par(1, 2) = 0.265157869877913d0
  g0par(2, 2) = -0.623695350637235d0
  g0par(3, 2) = 1.674633318254092d0
  g0par(4, 2) = 1.832031291880343d0
  g0par(5, 2) = -0.630177209092439d0
  g0par(6, 2) = -0.514436144698261d0
  g0par(1, 3) = 8.785016107647921d0
  g0par(2, 3) = -4.895140952257445d0
  g0par(3, 3) = -19.071047814522810d0
  g0par(4, 3) = -0.651246137053238d0
  g0par(5, 3) = 8.433900748345344d0
  g0par(6, 3) = -7.514200564005597d0
!
  g1par(1, 1) = -0.716696943349055d0
  g1par(2, 1) = -1.799379832289937d0
  g1par(3, 1) = -1.272374773587762d0
  g1par(4, 1) = -0.422537827515598d0
  g1par(5, 1) = -0.066726893855753d0
  g1par(6, 1) = 0.046805922626871d0
  g1par(1, 2) = -0.767216076396932d0
  g1par(2, 2) = 0.204506170017565d0
  g1par(3, 2) = -1.026962739406349d0
  g1par(4, 2) = -1.499270438208511d0
  g1par(5, 2) = 0.617151174631303d0
  g1par(6, 2) = 0.374467312887415d0
  g1par(1, 3) = -2.600511428982215d0
  g1par(2, 3) = 4.439659662444800d0
  g1par(3, 3) = 14.877518045476110d0
  g1par(4, 3) = 4.915499523879274d0
  g1par(5, 3) = -7.167713194561587d0
  g1par(6, 3) = 6.754486599741076d0
!
  g2par(1, 1) = 0.133466525438003d0
  g2par(2, 1) = 0.363354836255877d0
  g2par(3, 1) = 0.278274964310456d0
  g2par(4, 1) = 0.089554042766288d0
  g2par(5, 1) = 0.013086477976977d0
  g2par(6, 1) = -0.011042103563629d0
  g2par(1, 2) = 0.291554027998303d0
  g2par(2, 2) = 0.073924141379195d0
  g2par(3, 2) = 0.183942919605771d0
  g2par(4, 2) = 0.416043391498683d0
  g2par(5, 2) = -0.190246683084211d0
  g2par(6, 2) = -0.090246903296188d0
  g2par(1, 3) = -0.033889744561149d0
  g2par(2, 3) = -1.097798816676007d0
  g2par(3, 3) = -3.182774594628603d0
  g2par(4, 3) = -1.975283365814364d0
  g2par(5, 3) = 2.039158636810153d0
  g2par(6, 3) = -1.870762601953492d0
!
  g3par(1, 1) = -0.009525087912154d0
  g3par(2, 1) = -0.025258865602849d0
  g3par(3, 1) = -0.021827843859677d0
  g3par(4, 1) = -0.006926659963151d0
  g3par(5, 1) = -0.000880022720031d0
  g3par(6, 1) = 0.000834993057544d0
  g3par(1, 2) = -0.030968444075873d0
  g3par(2, 2) = -0.020411320334507d0
  g3par(3, 2) = -0.009669711535675d0
  g3par(4, 2) = -0.038366340553356d0
  g3par(5, 2) = 0.018653689407513d0
  g3par(6, 2) = 0.007343003097835d0
  g3par(1, 3) = 0.036634516644001d0
  g3par(2, 3) = 0.065423196677937d0
  g3par(3, 3) = 0.170669053301343d0
  g3par(4, 3) = 0.190098586427090d0
  g3par(5, 3) = -0.194641294138869d0
  g3par(6, 3) = 0.163741529410431d0
!
  c60par(1) = -1996.575537892978900d0
  c60par(2) = -0.307468414487437d0
  c60par(3) = 5.743607568908502d0
!
  c62par(1) = -388.206699666093300d0
  c62par(2) = -0.014941745228257d0
  c62par(3) = -0.235609028363907d0
!
  c71par(1) = 4059.088160207028977d0
  c71par(2) = 0.021629800103675d0
  c71par(3) = -0.101783055744035d0
!
  c73par(1) = 558.322859066182559d0
  c73par(2) = 0.017816070337537d0
  c73par(3) = -0.120764317323077d0
!
  diffd = bohr*rcod
  diff = (rco-re)*bohr
  rd(1) = one
  DO ii1=1,3
    rdd(ii1) = 0.D0
  END DO
  rdd(2) = diffd
  rd(2) = diff
  rdd(3) = 2*diff*diffd
  rd(3) = diff*diff
!
  c60 = zero
  c62 = zero
  c71 = zero
  c73 = zero
  DO i=1,6
    bc(i) = zero
    dc(i) = zero
    g0(i) = zero
    g1(i) = zero
    g2(i) = zero
    g3(i) = zero
  END DO
  DO ii1=1,6
    bcd(ii1) = 0.D0
  END DO
  DO ii1=1,6
    g0d(ii1) = 0.D0
  END DO
  DO ii1=1,6
    g1d(ii1) = 0.D0
  END DO
  DO ii1=1,6
    g2d(ii1) = 0.D0
  END DO
  DO ii1=1,6
    g3d(ii1) = 0.D0
  END DO
  c60d = 0.D0
  c62d = 0.D0
  c71d = 0.D0
  c73d = 0.D0
  DO ii1=1,6
    dcd(ii1) = 0.D0
  END DO
!
  DO j=1,3
    DO i=1,6
      bcd(i) = bcd(i) + bcpar(i, j)*rdd(j)
      bc(i) = bc(i) + bcpar(i, j)*rd(j)
      dcd(i) = dcd(i) + dcpar(i, j)*rdd(j)
      dc(i) = dc(i) + dcpar(i, j)*rd(j)
      g0d(i) = g0d(i) + g0par(i, j)*rdd(j)
      g0(i) = g0(i) + g0par(i, j)*rd(j)
      g1d(i) = g1d(i) + g1par(i, j)*rdd(j)
      g1(i) = g1(i) + g1par(i, j)*rd(j)
      g2d(i) = g2d(i) + g2par(i, j)*rdd(j)
      g2(i) = g2(i) + g2par(i, j)*rd(j)
      g3d(i) = g3d(i) + g3par(i, j)*rdd(j)
      g3(i) = g3(i) + g3par(i, j)*rd(j)
    END DO
    c60d = c60d + c60par(j)*rdd(j)
    c60 = c60 + c60par(j)*rd(j)
    c62d = c62d + c62par(j)*rdd(j)
    c62 = c62 + c62par(j)*rd(j)
    c71d = c71d + c71par(j)*rdd(j)
    c71 = c71 + c71par(j)*rd(j)
    c73d = c73d + c73par(j)*rdd(j)
    c73 = c73 + c73par(j)*rd(j)
  END DO
!
  RETURN
END SUBROUTINE PARINIT3_D

