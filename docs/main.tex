\documentclass{article}

\usepackage{amsmath}
\usepackage{graphicx} % Required for inserting images
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{xfrac}

% longtable environment can be broken down by page break
\usepackage{longtable} 

\usepackage[margin=1in,top=0.5in]{geometry}

\usepackage{tikz}
\newcommand{\recttext}[1]{%
  \begin{tikzpicture}[baseline=(text.base)]
    \node[align=center, inner sep=0.35em] (text) {#1};
    \draw (text.south west) rectangle (text.north east);
  \end{tikzpicture}
}

\newcommand{\lb}{\left(}
\newcommand{\rb}{\right)}
\newcommand{\mf}{\mathbf}
\newcommand*\diff{\mathop{}\!\mathrm{d}}


\newcommand{\libname}{\texttt{Hawaii Hybrid}\,}

\title{Documentation for \libname v.0.1}
\author{A. Finenko and D. Chistikov}
\date{\today}

\begin{document}

\maketitle

\tableofcontents
\newpage 

\section{Problems addressed by library}
\label{sec:tasks}

\begin{enumerate}
\item Compute statistical averages over ensembles of classical trajectories restricted by chosen phase-space domains (e.g., bound or unbound states), enabling the calculation of dipole autocorrelation functions. 
\item Calculate static phase-space averages using rejection sampling and adaptive Monte Carlo algorithms to estimate zeroth and second spectral moments.
\item Transform correlation functions into spectral functions, apply smoothing, and convert them into spectral profiles.
\end{enumerate}

\section{\libname code organization}
\label{sec:code-organization}

\subsection{Module \texttt{hawaii}}
\label{subsec:module-hawaii}


\recttext{\texttt{enum MonomerType}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Values & \texttt{ATOM = 0} \\
           & \texttt{LINEAR\_MOLECULE = 4} \\
           & \texttt{LINEAR\_MOLECULE\_REQUANTIZED\_ROTATION = MODULO\_BASE + 4} \\
           & {\color{red} \texttt{/* LINEAR\_VIBRATING\_MOLECULE = MODULO\_BASE + 6 */}} \\
           & \texttt{ROTOR = 6} \\
           & \texttt{ROTOR\_REQUANTIZED\_ROTATION = 2*MODULO\_BASE + 6} \\
    Description & This enum is used to distinguish between systems of different types and store the size of the phase point: \texttt{size(phase\_point) = MonomerType \% MODULO\_BASE}, where \texttt{MODULO\_BASE} is \texttt{\#define}d to 100 by default. 
\end{longtable} 

\noindent
\recttext{\texttt{enum PairState}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Values & \texttt{FREE\_AND\_METASTABLE} = 0 \\
           & \texttt{BOUND} = 1 \\
    Description & \\ 
\end{longtable} 


\noindent
\recttext{\texttt{enum CalculationType}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Values & \texttt{PRMU} = 0 \\
           & \texttt{CORRELATION\_SINGLE} = 1 \\
           & \texttt{CORRELATION\_ARRAY} = 2 \\
    Description & \\ 
\end{longtable} 

\noindent 
\recttext{\texttt{struct Monomer}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Fields & \texttt{MonomerType t} \\
           &  \texttt{double I[3]} -- values of tensor of inertia \\
           &  \texttt{double *qp} -- dynamic variables  {\color{red} (currently, Euler angles and conjugated momenta)} at the current step of simulation\\
           & \texttt{double *dVdq} -- the derivatives of potential energy with respect to coordinates pertaining to this monomer (the order of coordinates is the same as for \texttt{qp}) \\
           &  \texttt{bool apply\_requantization} \\
    Description & The \texttt{apply\_requantization} will be set to \texttt{true} in \texttt{rhs} to signal that the requantization of the monomer's angular momentum is required during trajectory propagation.  
    The order of variables in the \texttt{qp} array is specified by the following indices: \\
    & \texttt{\#define IPHI 0} \\
    & \texttt{\#define IPPHI 1} \\
    & \texttt{\#define ITHETA 2} \\
    & \texttt{\#define IPTHETA 3} \\
    & \texttt{\#define IPSI 4} \\
    & \texttt{\#define IPPSI 5} \\
\end{longtable} 

\noindent
\recttext{\texttt{struct MoleculeSystem}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Fields & \texttt{double intermolecular\_qp[6]} -- Coordinates and conjugated momenta that correspond to the intermolecular motion: ($\Phi$, $p_\Phi$, $\Theta$, $p_\Theta$, $R$, $p_R$). \\
           & \texttt{Monomer m1} \\
           & \texttt{Monomer m2} \\
           & \texttt{double mu} -- reduced mass of molecule pair \\
           & \texttt{size\_t Q\_SIZE} -- total number of coordinates for molecule pair \\
           & \texttt{size\_t QP\_SIZE} -- total number of coordinates and momenta for molecule pair (a.k.a. \texttt{size(phase\_point)}) \\
           & \texttt{double *intermediate\_q} -- contiguous vector of coordinates \\
           & \texttt{double *dVdq} -- contiguous vector of potential energy derivatives  \\
    Description &  Keep in mind that angular variables and momenta are stored in the same order as for \texttt{qp} in \texttt{Monomer}. These variables' locations are \texttt{\#define}d as follows: \\
    &  \texttt{\#define IPHI 0} \\
    & \texttt{\#define IPPHI 1} \\
    & \texttt{\#define ITHETA 2} \\
    & \texttt{\#define IPTHETA 3} \\
    & \texttt{\#define IR 4} \\
    & \texttt{\#define IPR 5} \\
    & Keep in mind that intermolecular coordinates and monomer's coordinates are not stored contiguously. The contiguous vector of coordinates can be assembled by calling \texttt{extract\_q\_and\_write\_into\_ms} function, which stores the coordinates in memory pointed at by \texttt{intermediate\_q}. These coordinates are passed to external functions that compute the values of intermolecular energy, its derivatives with respect to coordinates and induced dipole (see section~\ref{subsec:external-functions}).There is no guarantee that coordinates stored in \texttt{Monomer}'s and coordinates in memory at \texttt{intermediate\_q} are always in sync.  The function \texttt{extract\_q\_and\_write\_into\_ms} must be invoked if the contiguous vector of coordinates is desired at a certain point of the program execution. 
\end{longtable} 

\noindent
\recttext{\texttt{struct CFnc}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Fields & \texttt{double *t} \\
           & \texttt{double *data} \\
           & \texttt{size\_t len} -- number of samples in \texttt{*t} and \texttt{*data} \\
           & \texttt{size\_t capacity} -- capacity of \texttt{*t} and \texttt{*data} \\
           & \texttt{size\_t ntraj} -- number of trajectories used for averaging \\
           & \texttt{double Temperature} 
\end{longtable}

\noindent
\recttext{\texttt{struct SFnc}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Fields & \texttt{double *nu} \\
           & \texttt{double *data} \\
           & \texttt{size\_t len} -- number of samples in \texttt{*nu} and \texttt{*data} \\
           & \texttt{size\_t capacity} -- capacity of \texttt{*nu} and \texttt{*data} \\
           & \texttt{size\_t ntraj}  -- number of trajectories used for averaging \\
           & \texttt{double Temperature}
\end{longtable}

\noindent
\recttext{\texttt{struct Spectrum}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Fields & \texttt{double *nu} \\
           & \texttt{double *data} \\
           & \texttt{size\_t len} -- number of samples in \texttt{*nu} and \texttt{*data} \\
           & \texttt{size\_t capacity} -- capacity of \texttt{*nu} and \texttt{*data} \\
\end{longtable}

\noindent
\recttext{\texttt{struct CFncArray}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Fields & \texttt{double *t} \\
           & \texttt{double **data} \\
           & \texttt{size\_t ntemp} \\
           & \texttt{size\_t len} -- number of samples in \texttt{*t} and elements of \texttt{*data} \\
           & \texttt{double* nstar} -- number of effective trajectories at each temperature \\
           & \texttt{size\_t ntraj} - number of calculated trajectories at base temperature \\
    Description & An array of correlation functions for a fixed \texttt{base temperature} (sampling temperature) and a \texttt{satellite temperature} (target temperature for re-weighting).
\end{longtable}


\noindent
\recttext{\texttt{struct CalcParams}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Fields & \texttt{PairState ps} \\
           & \texttt{/* sampling */} \\
           & \texttt{double sampler\_Rmin // a.u.} \\ 
           & \texttt{double sampler\_Rmax // a.u.} \\
           & \texttt{double pesmin // Hartree} \\
           & \texttt{/* initial spectral moments check */} \\ 
           & \texttt{size\_t initialM0\_npoints} \\
           & \texttt{size\_t initialM2\_npoints} \\
           & \texttt{double partial\_partition\_function\_ratio} \\
           & \texttt{/* requantization */} \\ 
           & \texttt{size\_t torque\_cache\_len} \\
           & \texttt{double torque\_bound} \\
           & \texttt{/* trajectory */} \\
           & \texttt{double sampling\_time} \\
           & \texttt{size\_t MaxTrajectoryLength} \\
           & \texttt{double cvode\_tolerance} \\
           & \texttt{/* applicable to both correlation function AND spectral function calculations */} \\
           & \texttt{size\_t niterations} \\
           & \texttt{size\_t total\_trajectories} \\
           & \texttt{/*correlation function calculation ONLY */} \\
           & \texttt{const char *cf\_filename} \\
           & \texttt{double Rcut // distance at which the trajectory is forcefully stopped, a.u.} \\
           & \texttt{/* pr/mu calculation ONLY */} \\
           & \texttt{const char *sf\_filename} \\
           & \texttt{double ApproximateFrequencyMax // cm-1} \\
           & \texttt{double R0 // initial distance, a.u.} \\
           & \texttt{/*correlation function array ONLY */} \\
           & \texttt{double* partial\_partition\_function\_ratios} \\
           & \texttt{double *satellite\_temperatures} \\
           & \texttt{size\_t num\_satellite\_temperatures} \\
           & \texttt{const char **cf\_filenames} \\
\end{longtable} 



\noindent 
Function \recttext{\texttt{init\_ms}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{MoleculeSystem *ms = MoleculeSystem init\_ms(mu, t1, t2, I1, I2, seed)} \\
    Arguments & \texttt{double mu} -- the reduced mass of the molecule pair \\
              & \texttt{MonomerType t1} specifies the type of first monomer \\ 
              & \texttt{MonomerType t2} specifies the type of second monomer \\
              & \texttt{double* I1} contains inertia tensor values for first monomer. If the monomer is atom, no values will be read from the pointer, so \texttt{NULL} can be passed. Two and three values are expected for the rotor and linear molecule, respectively. \\
              & \texttt{double* I2} contains inertia tensor values for second monomer. \\
              & \texttt{size\_t seed} is the seed for random number generator. A unique seed will be produced if \texttt{0} is passed. \\
    Description & The function prepares the \texttt{MoleculeSystem} struct based on the specified monomer types, {\color{red} allocates the memory using \texttt{malloc}} (probably should be avoided due to cache locality) and initializes the random number generator. 
\end{longtable} 

\noindent
Function \recttext{\texttt{kinetic\_energy}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{double kinetic\_energy(*ms)} \\
    Arguments & \texttt{MoleculeSystem* ms} \\
    Description & The kinetic energy function is calculated at the phase-point stored in \texttt{MoleculeSystem}. {\color{red} Currently, implemented for intermolecular degrees of freedom, linear molecule (tested) and rotor (tested).}
    Parts of the kinetic energy corresponding to intermolecular degrees of freedom: 
    \begin{gather}
        \displaystyle T_\textrm{int} = \frac{p_R^2}{2 \mu} + \frac{p_\Theta^2}{2 \mu R^2} + \frac{p_\Phi^2}{2\mu R^2 \sin^2 \Theta}; \notag
    \end{gather}
    %
    to linear molecule:
    \begin{gather}
        \displaystyle T_\textrm{lin} = \frac{p_\theta^2}{2 I} + \frac{p_\varphi^2}{2 I \sin^2 \theta}; \notag
    \end{gather}
    to rotor:
    \begin{gather}
        \displaystyle T_\textrm{rotor} = \frac{1}{2 I_1 \sin^2 \theta_2} \Big[ \lb p_\varphi - p_\psi \cos \theta \rb \sin \psi + p_\theta \sin \theta \cos \psi \Big]^2 + \notag \\ 
        \displaystyle + \frac{1}{2 I_2 \sin^2 \theta} \Big[ \lb p_\varphi - p_\psi \cos \theta \rb \cos \psi - p_\theta \sin \theta \sin \psi \Big]^2 + \frac{1}{2 I_3} \lb p_\psi \rb^2. \notag 
    \end{gather}
\end{longtable}

\noindent
Function \recttext{\texttt{Hamiltonian}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{double Hamiltonian(*ms)} \\
    Arguments & \texttt{MoleculeSystem* ms} \\
    Description & Calls to \texttt{kinetic energy}, assembles a contiguous vector of coordinates via \texttt{extract\_q\_and\_write\_into\_ms} and passes it to external \texttt{pes}. 
\end{longtable} 

\noindent
Function \recttext{\texttt{q\_generator}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void q\_generator(*ms, *params)} \\
    Arguments & \texttt{MoleculeSystem* ms} \\
              & \texttt{CalcParams *params} \\
    Description & Generates $R$ with density $\rho \sim R^2$ in the range [\texttt{params.sampler\_Rmin}, \texttt{params.sampler\_Rmax}]. The distributions of $\varphi, \psi$ are $\varphi, \psi \sim U[0, 2\pi]$ and for $\theta$ is $\cos \theta \sim U[0, 1]$. Implemented for intermolecular degrees of freedom, linear molecule and rotor.
\end{longtable} 

\noindent
Function \recttext{\texttt{p\_generator}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void p\_generator(*ms, T)} \\
    Arguments & \texttt{MoleculeSystem* ms} \\
              & \texttt{double T} \\
    Description & Samples momenta $p$ from distribution $\rho \sim e^{-K/kT}$ at given temperature. Calls to \texttt{p\_generator\_linear\_molecule} and \texttt{p\_generator\_rotor} to sample momenta for monomers.
\end{longtable} 

\noindent
Function \recttext{\texttt{reject}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{bool reject(*ms, Temperature, pesmin)} \\
    Arguments & \texttt{MoleculeSystem* ms} \\
              & \texttt{double Temperature} \\
              & \texttt{double pesmin} -- the minimum value of PES \\
    Description & Applies the rejection step to the phase-point that is stored in the \texttt{MoleculeSystem}. It presupposes that the provided phase-point is sampled from $\rho \sim e^{-K/kT}$ using \texttt{q\_generator} and \texttt{p\_generator} functions. The random variable $u \sim U[0, 1]$ is chosen, to determine whether the current phase-point is to be accepted with probability $\rho \sim \exp(-H/kT)$.     
\end{longtable} 

\noindent
Function \recttext{\texttt{rhs}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void rhs(t, y, ydot, *user\_data);} \\
    Arguments & \texttt{UNUSED(realtype t)} \\
              & \texttt{N\_Vector y} stores coordinates and conjugated momenta \\
              & \texttt{N\_Vector ydot} is filled by function with numerical values of right-hand side of Hamilton's equations of motion  at provided phase point \\
              & \texttt{void *user\_data} is employed to pass \texttt{MoleculeSystem*} inside the function (see section \ref{subsec:cvode}) \\
    Description & This function is passed to \texttt{CVode} library to propagate the trajectory (see section \ref{subsec:cvode}).First, the phase-point coordinates are stored into \texttt{MoleculeSystem} struct. A contiguous vector of coordinates is assembled via \texttt{extract\_q\_and\_write\_into\_ms}. Next, by calling the external function \texttt{dpes}, the derivatives of potential energy are computed  and stored into \texttt{MoleculeSystem.dVdq}. The components of derivative vector are then copied into the field \texttt{Monomer.dVdq} of the corresponding monomer via the call to \texttt{extract\_dVdq\_and\_write\_into\_monomers}. The right-hand side of Hamilton's equations with respect to intermolecular degrees of freedom are readily obtained and filled into \texttt{ydot}, while the derivatives with respect to monomer's coordinates are handled by \texttt{rhsMonomer} function.
\end{longtable} 

\noindent
Function \recttext{\texttt{rhsMonomer}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void rhsMonomer(*m, *deriv);} \\
    Arguments & \texttt{Monomer *m} \\
              & \texttt{double *deriv} stores the right-hand side of Hamilton's equations of motion with respect to coordinates and momenta that correspond to the passed-in monomer \\
    Description &  In addition to differentiating the kinetic energy, the derivatives of potential energy, which are taken from \texttt{Monomer.dVdq}, are also added to compute the right-hand side. When \texttt{apply\_requantization} flag is set, then the momenta in \texttt{qp} are rescaled so that angular momentum is brought to the closest half-integer. 
    {\color{red} Implemented for cases of LINEAR\_MOLECULE (tested), LINEAR\_MOLECULE\_REQUANTIZED\_ROTATION (not tested enough) and ROTOR (tested).}
\end{longtable} 

\noindent
Function \recttext{\texttt{compute\_numerical\_rhs}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{Array compute\_numerical\_rhs(*ms, order);} \\
    Arguments & \texttt{MoleculeSystem *ms} \\
              & \texttt{size\_t order} -- the order of the central finite-difference formula (implemented for 2, 4 or 6) \\
    Description &  Computes numerically the right-hand side of the Hamiltonian equations of motion. The order corresponds to the order of variables employed in MoleculeSystem struct. 
\end{longtable}

\noindent
Function \recttext{\texttt{j\_monomer}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{double j\_monomer(m);} \\
    Arguments & \texttt{Monomer m} \\
    Description &  Computes the magnitude of angular momentum of passed-in monomer. {\color{red} Currently, implemented only for linear molecules.} 
    \begin{gather}
        [\textrm{linear molecule}]: j = \begin{bmatrix}
          - p_\theta \sin \varphi - p_\varphi \cos \varphi / \tan \theta \\
          p_\theta \cos \varphi - p_\varphi \sin \varphi / \tan \theta \\
          p_\varphi
        \end{bmatrix} \notag
    \end{gather}
\end{longtable}

\noindent
Function \recttext{\texttt{torque\_monomer}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{double torque\_monomer(m);} \\
    Arguments & \texttt{Monomer m} \\
    Description &  Computes the magnitude of torque of passed-in monomer. Needs the derivative of potential \texttt{m.dVdq} to be set within the monomer. {\color{red} Currently, implemented only for linear molecules.}
    \begin{gather}
        [\textrm{linear molecule}]: \tau = \begin{bmatrix}
            \displaystyle \sin \varphi \frac{\diff{V}}{\diff{\theta}} + \cos \varphi / \tan \theta \frac{\diff{V}}{\diff{\varphi}} \\
            \displaystyle -\cos \varphi \frac{\diff{V}}{\diff{\theta}} + \sin \varphi / \tan \theta \frac{\diff{V}}{\diff{\varphi}} \\
            \displaystyle -\frac{\diff{V}}{\diff{\varphi}}
        \end{bmatrix} \notag
    \end{gather}
\end{longtable} 

\noindent
Function \recttext{\texttt{invert\_momenta}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void invert\_momenta(*ms);} \\
    Arguments & \texttt{MoleculeSystem *ms} \\
    Description & Inverts the momenta stored inside MoleculeSystem. 
\end{longtable} 


\noindent
Function \recttext{\texttt{analytic\_full\_partition\_function\_by\_V}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{double analytic\_full\_partition\_function\_by\_V(*ms, *params, Temperature)} \\
    Arguments & \texttt{MoleculeSystem *ms} \\ 
              & \texttt{double Temperature} \\
    Description & Returns analytically calculated value for the ratio of the partition function for the totality of states to the volume. {\color{red} Currently, implemented only for linear molecule-atom and rotor-linear molecule.}
    \begin{gather}
        [\textrm{linear molecule - atom}]: Q = 4 \pi \times \lb 2 \pi \mu k T \rb^{3/2} \times (2 \pi I k T) \notag \\
        [\textrm{rotor - linear molecule}]: Q = 32 \pi^3 \times \lb 2 \pi \mu k T \rb^{3/2} \times (2 \pi k T)^{3/2} \sqrt{I_1^\textrm{rotor} I_2^\textrm{rotor} I_3^\textrm{rotor}} \times (2 \pi I^\textrm{lin}_1 k T) \notag 
    \end{gather}
\end{longtable}

\noindent
Function \recttext{\texttt{calculate\_M0}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void calculate\_M0(*ms, *params, Temperature, *m, *q);} \\
    Arguments & \texttt{MoleculeSystem *ms} \\
              & \texttt{CalcParams *params} \\
              & \texttt{double Temperature} \\
              & \texttt{double *m} -- the estimate of $M_0$  \\
              & \texttt{double *q} -- the error of the estimate \\
    Description & By sampling from $\rho \sim e^{-K/kT}$  and rejecting some of the points using the \texttt{reject} function, \texttt{params.initialM0\_npoints} phase-points are produced to estimate $M_0$ and its error. The average over the sampled phase-points is multiplied by the \texttt{params.partial\_partition\_function\_ratio}, which is supposed to be a ratio of the partition function over the part of the phase space that is pertinent to the select pair state to the total partition function and multiplied by volume. {\color{blue} This ratio can be calculated using \texttt{mpi\_perform\_integration} function that invokes hep library.}
\end{longtable} 

\noindent
Function \recttext{\texttt{compute\_dHdp}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}} 
    Call & \texttt{void compute\_dHdp(*ms, *dHdp);} \\
    Arguments & \texttt{MoleculeSystem *ms} \\
              & \texttt{gsl\_matrix *dHdp} \\
    Description & Calls to \texttt{rhsMonomer} to fill in derivatives of Hamiltonian with respect to momenta pertaining to monomers.
\end{longtable}

\noindent
Function \recttext{\texttt{calculate\_M2}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void calculate\_M0(*ms, *params, Temperature, *m, *q);} \\
    Arguments & \texttt{MoleculeSystem *ms} \\
              & \texttt{CalcParams *params} \\
              & \texttt{double Temperature} \\
              & \texttt{double *m} -- the estimate of $M_2$  \\
              & \texttt{double *q} -- the error of the estimate \\
    Description & By sampling from $\rho \sim e^{-K/kT}$  and rejecting some of the points using the \texttt{reject} function, \texttt{params.initialM2\_npoints} phase-points are produced to estimate $M_2$ and its error. The derivative of dipole with respect to coordinates is done using cental 2-point finite-difference formula. The energy is differentiated with respect to momenta using \texttt{compute\_dHdp}. Here we use GSL's wrappers over BLAS to conduct matrix-by-vector multiplication. The average over the sampled phase-points is multiplied by the \texttt{params.partial\_partition\_function\_ratio}, which is supposed to be a ratio of the partition function over the part of the phase space that is pertinent to the select pair state to the total partition function and multiplied by volume. {\color{blue} This ratio can be calculated using \texttt{mpi\_perform\_integration} function that invokes hep library.}
\end{longtable} 

\noindent
MPI Function \recttext{\texttt{mpi\_calculate\_M0}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void calculate\_M0(*ms, *params, Temperature, *m, *q);} \\
    Arguments & \texttt{MoleculeSystem *ms} \\
              & \texttt{CalcParams *params} \\
              & \texttt{double Temperature} \\
              & \texttt{double *m} \\
              & \texttt{double *q} \\
    Description & The task of iterating \texttt{params.initialM0\_npoints} points is split equally between processes of communicator. The behavior is the same as in \texttt{calculate\_M0}.
\end{longtable} 

\noindent
MPI Function \recttext{\texttt{mpi\_calculate\_M2}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void calculate\_M2(*ms, *params, Temperature, *m, *q);} \\
    Arguments & \texttt{MoleculeSystem *ms} \\
              & \texttt{CalcParams *params} \\
              & \texttt{double Temperature} \\
              & \texttt{double *m} \\
              & \texttt{double *q} \\
    Description & The task of iterating \texttt{params.initialM2\_npoints} points is split equally between processes of communicator. The behavior is the same as in \texttt{calculate\_M2}.
\end{longtable} 

\noindent
Function \recttext{\texttt{correlation\_eval}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{int correlation\_eval(*ms, *traj, *params, *crln, *tps);} \\
    Arguments & \texttt{MoleculeSystem *ms} \\ 
              & \texttt{Trajectory *traj} \\
              & \texttt{CalcParams *params} \\
              & \texttt{double *crln} \\
              & \texttt{int *tps} \\
    Description & Evaluates the mean between forward and backward correlation functions from the initial condition set in the \texttt{*ms}. It also tracks the number of turning points and returns it using the output parameter \texttt{*tps}.
\end{longtable} 



\noindent
MPI Function \recttext{\texttt{calculate\_correlation\_and\_save}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{CFnc calculate\_correlation\_and\_save(*ms, *params, Temperature);} \\
    Arguments & \texttt{MoleculeSystem *ms} \\ 
              & \texttt{CalcParams *params} \\
              & \texttt{double Temperature} \\
    Description & First, estimates of the zeroth and second specral moments are obtained using \texttt{params.initialM0\_npoints} and \texttt{params.initialM2\_npoints} points, respectively. The accumulation of \texttt{params.total\_trajectories} individual correlation functions is divided into \texttt{params.niterations} iterations. The individual correlation functions are obtained using \texttt{correlation\_eval} function. The current aggregate estimate of the correlation function is saved to \texttt{params.cf\_filename} at the end of each iteration. The zeroth moment based on the current estimate of the correlation function is made and compared to the value obtained during static phase-space sampling. {\color{red} NEED to correct the calculation of the estimate of the second moment based on the current correlation function}. 
    {\color{red} If \texttt{FREE\_AND\_METASTABLE} pair state is requested, then we SHOULD divide the contributions depending on the number of turning points provided by \texttt{correlation\_eval}.} The tracking of the number of turning points is already implemented. 
    The communication between processes is realized using \texttt{MPI\_Allreduce} function.  
\end{longtable} 

\noindent
MPI Function \recttext{\texttt{ calculate\_spectral\_function\_using\_prmu\_representation}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{SFnc calculate\_spectral\_function\_using\_prmu\_representation\_and\_save(*ms, *params, Temperature)} \\
    Arguments & \texttt{MoleculeSystem *ms} \\ 
              & \texttt{CalcParams *params} \\
              & \texttt{double Temperature} \\
    Description & First, we check that \texttt{params.ApproximateFrequencyMax} is less than Nyquist frequency of the signal that will be sampled with requested \texttt{params.sampling\_time}. Then, based on the calculated frequency step, a length of the frequency array is calculated. Since the frequency step depends on the \texttt{params.sampling\_time} and \texttt{params.MaxTrajectoryLength}, the maximum frequency of the calculated spectral function will be somewhat close to the requested \texttt{params.ApproximateFrequencyMax} (as close as possible using the frequency step). The estimates of the zeroth and second spectral moments are obtained using \texttt{params.initialM0\_npoints} and \texttt{params.initialM2\_npoints}, respectively. The accumulation of \texttt{params.total\_trajectories} is divided into \texttt{params.niterations}. For each trajectory the intermolecular distance is set to \texttt{params.R0}. The trajectory is cut at the same distance \texttt{params.R0}. 
    Connes apodization is applied to time dependencies of Cartesian components of dipole throughout collisional trajectory before applying Fourier transform to them. The length of the dipole array which is equal to \texttt{params.MaxTrajectoryLength} needs to be a power of 2. The current estimate of the spectral function is saved to \texttt{params.sf\_filename} at the end of each iteration. The zeroth and second spectral moments are obtained from the current estimate of the spectral function and compared to the values obtained through static phase-space sampling.     
\end{longtable} 
 
\noindent
MPI Function \recttext{\texttt{calculate\_correlation\_array\_and\_save}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{CFncArray calculate\_correlation\_array\_and\_save(*ms, *params, Temperature);} \\
    Arguments & \texttt{MoleculeSystem *ms} \\ 
              & \texttt{CalcParams *params} \\
              & \texttt{double base\_temperature} \\
    Description &  
\end{longtable} 


\noindent
Function \recttext{\texttt{connes\_apodization}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void connes\_apodization(a, sampling\_time);} \\
    Arguments & \texttt{Array a} \\
              & \texttt{double sampling\_time} \\
    Description & Multiplies the provided array by Connes apodization with time-normalization factor ($a$) set to \texttt{sampling\_time}: $A(t)= (1 - t^2/a^2)^2$. See \href{https://mathworld.wolfram.com/ConnesFunction.html}{link}.
\end{longtable}

\subsection{Processing results}
\label{subsec:processing}

\noindent
Function \recttext{\texttt{save\_correlation\_function}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void save\_correlation\_function(*fp, cf, *params);} \\
    Arguments & \texttt{FILE *fp} \\
              & \texttt{CFnc cf} \\
              & \texttt{CalcParams *params} \\
    Description & The correlation function values \texttt{cf.data} assumed to be unnormalized by the number of trajectories \texttt{cf.ntraj}. The file stream \texttt{fp} is truncated using \texttt{ftruncate} before writing into it.
\end{longtable}

\noindent
Function \recttext{\texttt{save\_spectral\_function}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void save\_spectral\_function(*fp, sf, *params);} \\
    Arguments & \texttt{FILE *fp} \\
              & \texttt{SFnc sf} \\
              & \texttt{CalcParams *params} \\
    Description & The spectral function values \texttt{sf.data} assumed to be unnormalized by the number of trajectories \texttt{sf.ntraj}. The file stream \texttt{fp} is truncated using \texttt{ftruncate} before writing into it.
\end{longtable}

\noindent
Function \recttext{\texttt{read\_correlation\_function}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{bool read\_correlation\_function(*filename, *sb, *cf);} \\
    Arguments & \texttt{const char *filename} \\
              & \texttt{String\_Builder *sb} \\
              & \texttt{CFnc *cf} \\
    Description & Reads the correlation function from the file \texttt{filename} expecting a header containing metainformation (the lines should begin with \texttt{'\#'}) and data presented in the two-column format. The header is read into \texttt{String\_Builder} without parsing. The numerical values are parsed using \texttt{fscanf} function and checked to be non-NaN. Returns \texttt{false} when either the file could no be correctly opened to a parser error was encountered.  
\end{longtable}

\noindent
Function \recttext{\texttt{read\_spectral\_function}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{bool read\_spectral\_function(*filename, *sb, *sf);} \\
    Arguments & \texttt{const char *filename} \\
              & \texttt{String\_Builder *sb} \\
              & \texttt{SFnc *sf} \\
    Description & Reads the spectral function from the file \texttt{filename} expecting a header containing metainformation (the lines should begin with \texttt{'\#'}) and data presented in the two-column format. The header is read into \texttt{String\_Builder} without parsing. The numerical values are parsed using \texttt{fscanf} function and checked to be non-NaN. Returns \texttt{false} when either the file could no be correctly opened to a parser error was encountered.  
\end{longtable}

\noindent
Function \recttext{\texttt{integrate\_composite\_simpson}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{double integrate\_composite\_simpson(*x, *y, len);} \\
    Arguments & \texttt{double *x} \\ 
              & \texttt{double *y} \\
              & \texttt{size\_t len} \\
    Description & Performs numerical integration using composite Simpson's 3/8 rule. See \href{https://en.wikipedia.org/wiki/Simpson%27s_rule}{link}.
\end{longtable}

\noindent
Function \recttext{\texttt{compute\_M0\_from\_sf}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{double compute\_M0\_from\_sf(sf);} \\
    Arguments & \texttt{SFnc sf} \\
    Description & Computes the zeroth moment of the spectral function using \texttt{integrate\_composite\_simpson}. The dimensions of the frequency and spectral function values are expected to be $\textrm{cm}^{-1}$ and $\textrm{J} \cdot \textrm{m}^6 \cdot \textrm{s}^{-1}$, respectively. The zeroth moment is returned in units of $\textrm{cm}^{-1} \cdot \textrm{Amagat}^{-2}$.  
\end{longtable}

\noindent
Function \recttext{\texttt{compute\_M2\_from\_sf}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{double compute\_M2\_from\_sf(sf);} \\
    Arguments & \texttt{SFnc sf} \\
    Description & Computes the second moment of the spectral function using \texttt{integrate\_composite\_simpson}. The dimensions of the frequency and spectral function values are expected to be $\textrm{cm}^{-1}$ and $\textrm{J} \cdot \textrm{m}^6 \cdot \textrm{s}^{-1}$, respectively. The zeroth moment is returned in units of $\textrm{cm}^{-3} \cdot \textrm{Amagat}^{-2}$.
\end{longtable}




\noindent
\recttext{\texttt{struct WingParams}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Fields & \texttt{double A} \\
           & \texttt{double B} \\
           & \texttt{double C} \\
    Description & Stores the parameters for the Lorentzian function shifted vertically by constant value: 
    \begin{gather}
        y = C + A/(1 + B^2 x^2). \notag
    \end{gather}
\end{longtable}

\noindent
\recttext{\texttt{struct WingData}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Fields & \texttt{size\_t n} \\
           & \texttt{double *t} \\
           & \texttt{double *y} \\
    Description & 
\end{longtable}

\noindent
Function \recttext{\texttt{wingmodel}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{double wingmodel(*wp, t);} \\
    Arguments & \texttt{WingParams *wp} \\
              & \texttt{double t} \\
    Description &
\end{longtable}

\noindent
Function \recttext{\texttt{fit\_baseline}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{WingParams fit\_baseline(*cf, EXT\_RANGE\_MIN);} \\
    Arguments & \texttt{CFnc *cf} \\
              & \texttt{size\_t EXT\_RANGE\_MIN} \\
    Description &
\end{longtable}

\noindent
Function \recttext{\texttt{idct}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{double* idct(*v, len);} \\
    Arguments & \texttt{double *v} \\
              & \texttt{size\_t len} \\
    Description &
\end{longtable}

\noindent
Function \recttext{\texttt{dct\_numeric\_sf}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{SFnc dct\_numeric\_sf(cf, *wp);} \\
    Arguments & \texttt{CFnc cf} \\
              & \texttt{WingParams *wp} \\
    Description &
\end{longtable}

\noindent
Function \recttext{\texttt{desymmetrize\_sch}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{SFnc desymmetrize\_sch(sf);} \\
    Arguments & \texttt{SFnc sf} \\
    Description &
\end{longtable}

\noindent
Function \recttext{\texttt{compute\_alpha}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{Spectrum compute\_alpha(sf);} \\
    Arguments & \texttt{SFnc sf} \\
    Description & \\
\end{longtable}

\subsection{Interfacing with \texttt{CVode} library}
\label{subsec:cvode}

\noindent
\recttext{\texttt{struct Trajectory}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Fields & \texttt{size\_t DIM} \\
           & \texttt{size\_t mxsteps} \\
           & \texttt{N\_Vector y} \\
           & \texttt{N\_Vector abstol} \\
           & \texttt{N\_Vector reltol} \\
           & \texttt{SUNMatrix A} \\
           & \texttt{SUNLinearSolver LS} \\
           & \texttt{void *cvode\_mem} \\
    Description & 
\end{longtable}

\noindent
Function \recttext{\texttt{init\_trajectory}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{Trajectory init\_trajectory(*ms, *transformed, reltol);} \\
    Arguments & \texttt{MoleculeSystem *ms} \\
              & \texttt{double reltol} \\
    Description & 
\end{longtable}

\noindent
Function \recttext{\texttt{free\_trajectory}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void free\_trajectory(*traj);} \\
    Arguments & \texttt{Trajectory *traj} \\
    Description & 
\end{longtable}

\noindent
Function \recttext{\texttt{reinit\_trajectory}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void reinit\_trajectory(*traj, t);} \\
    Arguments & \texttt{Trajectory *traj} \\
              & \texttt{double t} \\
    Description & 
\end{longtable}

\noindent
Function \recttext{\texttt{make\_step}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{int make\_step(*traj, tout, *t);} \\
    Arguments & \texttt{Trajectory *traj} \\
              & \texttt{double tout} \\
              & \texttt{double *t} \\
    Description & 
\end{longtable}

\noindent
Function \recttext{\texttt{set\_initial\_condition}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void set\_initial\_condition(*traj, qp);} \\
    Arguments & \texttt{Trajectory *traj} \\
              & \texttt{Array qp} \\
    Description & 
\end{longtable}

\noindent
Function \recttext{\texttt{make\_vector}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{N\_Vector make\_vector(size);} \\
    Arguments & \texttt{int size} \\
    Description & 
\end{longtable}

\noindent
Function \recttext{\texttt{set\_tolerance}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void set\_tolerance(*traj, tolerance);} \\
    Arguments & \texttt{Trajectory *traj} \\
              * \texttt{double tolerance} \\
    Description & 
\end{longtable}

\subsection{Interfacing with hep}
\label{subsec:hep}

\noindent
Function \recttext{\texttt{transform\_variables}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void transform\_variables(x, *transformed, *Jac);} \\
    Arguments & \texttt{hep::mc\_point<double> const\& x} \\
              & \texttt{double *transformed} \\
              & \texttt{double *Jac} \\
    Description & Transforms a point $x$ from $n$-dimensional hypercube $[0, 1]^n$ to a point in phase-space of the \texttt{MoleculeSystem} (which is passed in using global pointer). The following transformations are implemented
    \begin{gather}
        R \leftarrow 1/x, \notag \\
        \theta \leftarrow \pi x, \notag \\
        \phi \leftarrow 2 \pi x, \notag \\
        p \leftarrow \tan(\pi (x - \sfrac{1}{2})). \notag
    \end{gather}
    %
    The jacobian of the transformation is accumulated along the steps. {\color{red} Implemented for linear molecule-atom and rotor-linear molecule pairs.}  
\end{longtable}

\noindent
Function \recttext{\texttt{integrand\_pf}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{double integrand\_pf(x);} \\
    Arguments & \texttt{hep::mc\_point<double> const\& x} \\
    Description & Based on the point in hypercube returns the value of the following integrand:
    \begin{gather}
        \textrm{jac} \cdot \exp \lb -\frac{E}{k T} \rb. \notag
    \end{gather}
    %
    (The energy is computed for \texttt{MoleculeSystem} that is passed in using global pointer.) 
\end{longtable}

\noindent
Function \recttext{\texttt{integrand\_M0}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{double integrand\_M0(x);} \\
    Arguments & \texttt{hep::mc\_point<double> const\& x} \\
    Description & Based on the point in hypercube returns the value of the following integrand:
    \begin{gather}
        \textrm{jac} \cdot \mu^2 \cdot \exp \lb -\frac{E}{k T} \rb. \notag 
    \end{gather}
    %
    (The energy is computed for \texttt{MoleculeSystem} that is passed in using global pointer. The pointer to dipole function is also assumed to be set globally.)
\end{longtable}

\noindent
Function \recttext{\texttt{integrand\_M2}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{double integrand\_M2(x);} \\
    Arguments & \texttt{hep::mc\_point<double> const\& x} \\
    Description & Based on the point in hypercube returns the value of the following integrand:
    \begin{gather}
        \textrm{jac} \cdot \Big[ \mu, H \Big] \cdot \exp \lb -\frac{E}{k T} \rb. \notag 
    \end{gather}
    %
    The derivative of dipole with respect to coordinates is computed using 2-point central finite-difference formula. (The energy is computed for \texttt{MoleculeSystem} that is passed in using global pointer. The pointer to dipole function is also assumed to be set globally.)
\end{longtable}

\noindent
Function \recttext{\texttt{mpi\_perform\_integration}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{double mpi\_perform\_integration(*ms, integrand, *params, Temperature, niterations, npoints, *m, *q);} \\
    Arguments & \texttt{MoleculeSystem *ms} \\
              & \texttt{Integrand integrand} -- \texttt{typedef double (*Integrand)(hep::mc\_point<double> const\&)}\\
              & \texttt{CalcParams *params} \\
              & \texttt{double Temperature} \\
              & \texttt{size\_t niterations} \\
              & \texttt{size\_t npoints} \\
              & \texttt{double *m} \\
              & \texttt{double *q} \\
    Description & Evaluates the integral of requested \texttt{integrand} 
\end{longtable}

\subsection{Functions to transform angles between frames of reference}
\label{subsec:angle-transformation}

\noindent
Function \recttext{\texttt{linear\_molecule\_atom\_lab\_to\_mol}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void linear\_molecule\_atom\_lab\_to\_mol(*qlab, *qmol);} \\
    Arguments & \texttt{double *qlab} \\
              & \texttt{double *qmol} \\
    Description &
\end{longtable}

\noindent
Function \recttext{\texttt{linear\_molecule\_atom\_Jacobi\_mol\_by\_lab}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void linear\_molecule\_atom\_Jacobi\_mol\_by\_lab(jac, *qlab, *qmol);} \\
    Arguments & \texttt{Eigen::Ref<Eigen::MatrixXd> jac} \\
              & \texttt{double *qlab} \\
              & \texttt{double *qmol} \\
    Description &
\end{longtable}

\noindent
Function \recttext{\texttt{CH4\_linear\_molecule\_lab\_to\_kal}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void CH4\_linear\_molecule\_lab\_to\_kal(*qlab, *qkal);} \\
    Arguments & \texttt{double *qlab} \\
              & \texttt{double *qkal} \\
    Description &
\end{longtable}

\noindent
Function \recttext{\texttt{CH4\_linear\_molecule\_Jacobi\_kal\_by\_lab}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void CH4\_linear\_molecule\_Jacobi\_kal\_by\_lab(jac, *qlab, *qkal);} \\
    Arguments & \texttt{Eigen::Ref<Eigen::MatrixXd> jac} \\
              & \texttt{double *qlab} \\
              & \texttt{double *qkal} \\
    Description &
\end{longtable}

\subsection{Utility structs \& functions}
\label{subsec:utility}

\noindent
\recttext{\texttt{struct Array}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Fields & \texttt{double *data} \\
           & \texttt{size\_t n} \\
    Description & Sized array in dynamic memory.
\end{longtable}

\noindent
Function \recttext{\texttt{create\_array}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{Array create\_array(n);} \\
    Arguments & \texttt{size\_t n} \\
    Description &
\end{longtable}

\noindent
Function \recttext{\texttt{init\_array}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void init\_array(n);} \\
    Arguments & \texttt{Array *a} \\
              & \texttt{double *data} \\
              & \texttt{size\_t n} \\
    Description &
\end{longtable}

\noindent
Function \recttext{\texttt{free\_array}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void free\_array(n);} \\
    Arguments & \texttt{Array *a} \\
    Description &
\end{longtable}


\noindent
\recttext{\texttt{struct String\_Builder}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Fields & \texttt{char *items} -- dynamically allocated buffer holding the string data \\
           & \texttt{size\_t count} -- the current number of characters in the buffer \\
           & \texttt{size\_t capacity} -- the total allocated capacity of the buffer in bytes \\ 
    Description & This struct represents a resizable buffer designed to build strings dynamically. It stores characters in a contiguous block of memory, allowing for manipulation of strings.
\end{longtable}

\noindent
Function \recttext{\texttt{sb\_append}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void sb\_append(*sb, *line, n);} \\
    Arguments & \texttt{String\_Builder *sb} \\
              & \texttt{const char *line} \\
              & \texttt{size\_t n} \\
    Description & Appends a sequence of characters to the \texttt{String\_Builder}. This function appends the first `n` characters from the provided `line` to the \texttt{String\_Builder}. If `n` exceeds the length of `line`, the behavior is undefined. The \texttt{String\_Builder} automatically resizes its buffer if necessary to accommodate the new characters.
\end{longtable}

\noindent
Function \recttext{\texttt{sb\_append\_cstring}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void sb\_append(*sb, *line, n);} \\
    Arguments & \texttt{String\_Builder *sb} \\
              & \texttt{const char *line} \\
    Description & This function appends a C-style (null-terminated) string \texttt{line} to the \texttt{String\_Builder}'s buffer. If the \texttt{String\_Builder} does not have sufficient capacity, its storage is automatically extended to accommodate the new content. If the \texttt{String\_Builder}'s capacity is zero, it is first resized to \texttt{INIT\_SB\_CAPACITY} bytes before any extension occurs.
\end{longtable}

\noindent
Function \recttext{\texttt{sb\_append\_format}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void sb\_append\_format(*sb, *format, ...);} \\
    Arguments & \texttt{String\_Builder *sb} \\
              & \texttt{const char *format} \\
              & \texttt{varargs(...)} \\
    Description & This function takes a format string and a variable number of arguments, formats them according to the specified format, and appends the resulting string to the provided \texttt{String\_Builder}.  If the \texttt{String\_Builder} lacks sufficient capacity, its storage is automatically extended to accommodate the new content. If the \texttt{String\_Builder}'s capacity is zero, it is first resized to \texttt{INIT\_SB\_CAPACITY} bytes before any extension occurs.
\end{longtable}

\noindent
Function \recttext{\texttt{sb\_reset}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void sb\_reset(*sb);} \\
    Arguments & \texttt{String\_Builder *sb} \\
    Description & This function effectively clears the content of the \texttt{String\_Builder} by setting its length to zero. The underlying buffer is not deallocated, allowing it to be reused for subsequent operations. 
\end{longtable}


\noindent
Function \recttext{\texttt{sb\_free}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void sb\_free(*sb);} \\
    Arguments & \texttt{String\_Builder *sb} \\
    Description & This function releases the memory held by the internal buffer of the \texttt{String\_Builder} and resets the fields. 
 \end{longtable}

\subsection{External functions}
\label{subsec:external-functions}

The potential energy and its derivatives are expected to be provided as functions with the following signatures:   

\noindent
Function \recttext{\texttt{pes}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{double pes(*q);} \\
    Arguments & \texttt{double *q} \\
    Description & An array of \texttt{Q\_SIZE} variables is passed to this function; \texttt{MoleculeSystem} describes their order. Intermolecular distance measured in Bohrs, while angles are measured in radians. The function is expected to return energy in Hartree.
\end{longtable}

\noindent
Function \recttext{\texttt{dpes}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void dpes(*q, *dpesdq);} \\
    Arguments & \texttt{double *q} \\
              & \texttt{double *dpesdq} \\
    Description & An array of \texttt{Q\_SIZE} variables is passed to this function; \texttt{MoleculeSystem} describes their order. Intermolecular distance measured in Bohrs, while angles are measured in radians. The function is expected to return an array of derivatives of energy in units of Hartree/Bohr of length \texttt{Q\_SIZE}.
\end{longtable}

\noindent
Function \recttext{\texttt{dipole}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void dpes(*q, *dpesdq);} \\
    Arguments & \texttt{double *q} \\
              & \texttt{double *dpesdq} \\
    Description &
\end{longtable}

\texttt{pes} and \texttt{dpes} are defined as external functions in the header \texttt{hawaii.h}, so they have to be implemented in the user program, whereas the dipole function needs to be set through function pointer named \texttt{dipole}. 


\noindent
\textbf{Supplied routines:}
\begin{enumerate}
    \item spherical decomposition for \textit{ab initio} PES for CO$_2-$Ar (Kalugina/Lokshtanov) 
    \item spherical decomposition for \textit{ab initio} IDS for CO$_2-$Ar (Kalugina/Lokshtanov)
    \item spherical decomposition for \textit{ab initio} PES for CH$_4-$CO$_2$ (Finenko)
    \item spherical decomposition for \textit{ab initio} IDS for CH$_4-$CO$_2$ (Finenko)
    \item spherical decomposition for \textit{ab initio} PES for H$_2-$Ar (LeRoy/Chistikov)
    \item spherical decomposition for \textit{ab initio} PES for CO$-$Ar (Pederson)
\item spherical decomposition for \textit{ab initio} IDS for CO$-$Ar (Rizzo)
\end{enumerate}

\noindent
{\textbf{Routines to be added in the future:}}
\begin{enumerate}
\item spherical decomposition for full-dimensional \textit{ab initio} PES for N$_2-$Ar (Finenko)
\item PIP-NN representation for \textit{ab initio} PES surface for N$_2-$Ar (Finenko)
\item PIP-NN representation for \textit{ab initio} IDS surface for N$_2-$Ar (Finenko)
\item spherical decomposition for long-range IDS for N$_2-$Ar (Wang)
\item spherical decomposition for long-range $\textrm{d}\mu/\textrm{d}r$ surface for N$_2-$Ar (Wang)
\item spherical decomposition for long-range IDS for H$_2-$Ar (Kalugina)
\item spherical decomposition for \textit{ab initio} induced dipole for H$_2-$Ar (Meyer)
\item PIP-NN representation for \textit{ab initio} IDS for H$_2-$Ar (Meyer/Finenko)
\item spherical decomposition for \textit{ab initio} PES for CO$_2-$CO$_2$ (Kalugina/Lokshtanov)
\item spherical decomposition for \textit{ab initio} IDS for CO$_2-$CO$_2$ (Kalugina/Lokshtanov)
\item spherical decomposition for \textit{ab initio} PES for N$_2-$N$_2$ (Karman/Chistikov)
\item spherical decomposition for \textit{ab initio} IDS for N$_2-$N$_2$ (Karman/Chistikov)
\item spherical decomposition for \textit{ab initio} PES for N$_2-$H$_2$ (Kalugina)
\item spherical decomposition for long-range IDS for N$_2-$H$_2$ (Kalugina)
\item spherical decomposition for \textit{ab initio} PES for CH$_4-$N$_2$ (Finenko)
\item spherical decomposition for \textit{ab initio} IDS for CH$_4-$N$_2$ (Finenko)
\item PIP-NN representation for full-dimensional \textit{ab initio} PES for CH$_4-$N$_2$ (Finenko)
\end{enumerate}



\section{A skeleton of the user's program}
\label{sec:user-program}

For now, let us assume that the user is supposed to use \libname as a library, not via the configuration file to a driver program (which could be arranged in the future). Then the following structure is expected:

\begin{enumerate}

\item \textbf{Initialize parallel environment} \\
Call \texttt{MPI\_Init} to initialize MPI if desired.

\item \textbf{Initialize \texttt{MoleculeSystem}} \\
Call \texttt{init\_ms} specifying types of monomers, their tensors of inertia, the reduced mass of the molecule pair and the generator seed.

\item ...

\end{enumerate}


\section{Serial examples}
\label{sec:serial-examples}

\subsection{Propagating trajectory for CO$_2-$Ar}
\label{subsec:example-trajectory}

As an initial illustration of the use of \libname package, we give a sample program called \texttt{trajectory\_co2\_ar.cpp} to propagate a trajectory of collision between CO$_2$ and Ar. The problem consists of solving the following Hamilton dynamical equations:

\begin{align*}
    \dot{R} &= \frac{p_R}{m}, \\
    \dot{p}_R &= \frac{p_\Theta^2}{m R^3} + \frac{p_\Phi^2}{m R^3 \sin^2 \Theta} - \frac{\partial U}{\partial R}, \\
    \dot{\Phi} &= \frac{p_\Phi}{m R^2 \sin^2 \Theta}, \\
    \dot{p}_\Phi &= -\frac{\partial U}{\partial \Phi}, \\
    \dot{\Theta} &= \frac{p_\Theta}{m R^2}, \\
    \dot{p}_\Theta &= \frac{p_\Phi^2 \cos \Theta}{m R^2 \sin^3 \Theta} - \frac{\partial U}{\partial \Theta}, \\
    \dot{\varphi}_1 &= \frac{\displaystyle p_1^{\varphi}}{I_1 \sin^2 \vartheta_1}, \\
    \dot{p}_1^{\varphi} &= -\frac{\partial U}{\partial \varphi_1}, \\
    \dot{\vartheta}_1 &= \frac{p_1^\vartheta}{I_1}, \\ 
    \dot{p}_1^{\theta} &= \frac{\displaystyle \lb p_1^\varphi \rb^2 \cos \theta_1}{I_1 \sin^3 \theta_1} - \frac{\partial U}{\partial \theta_1}.
\end{align*}
%
The \texttt{hawaii.h} header files provides definition of the struct \texttt{MoleculeSystem} that is used to evaluate the right-hand side of the dynamical equations. The \texttt{trajectory.h} header provides struct \texttt{Trajectory} that provides interface with \texttt{CVode} library that performs the integration of dynamical equations (see Section~\ref{subsec:cvode}).
Next, we provide implementations for functions that calculate potential energy \texttt{pes} and its derivatives with respect to coordinates \texttt{dpes}. Each user program that instantiates the \texttt{MoleculeSystem} is expected to implement these functions. To implement these functions \texttt{hawaii} provides functions to transform angles between different reference frames (see Section~\ref{subsec:angle-transformation}).      


\subsection{Propagating trajectory for H$_2-$Ar while requantizing the angular momentum of H$_2$}
\label{subsec:example-req-trajectory}


\subsection{Processing correlation function for CO$_2-$Ar}
\label{subsec:example-processing}

\section{Parallel examples}
\label{sec:parallel-examples}

\subsection{Calculating the zeroth and second spectral moments of CO$_2-$Ar as phase-space averages using rejection-based sampler}
\label{subsec:example-spmoments-co2-ar}

This example demonstrates how to use interface with \texttt{hep} to calculate spectral moments. First, the zeroth moment over unbound states is calculated as follows:
\begin{gather}
    M_0 = \frac{(2 \pi)^4 N_L^2}{3 (Q/V) h} \frac{1}{4 \pi \epsilon_0} \frac{1}{2 \pi c} \int\limits_{\Omega: H > 0} \mu^2 \exp \lb -\frac{H}{kT} \rb \diff{\mf{q}} \diff{\mf{p}}. \notag
\end{gather}
%
The integral is evaluated using \texttt{mpi\_perform\_integration}, whereas the partition can be calculated using \texttt{analytic\_full\_partition\_function\_by\_V}.    


\subsection{Calculating a single correlation function for CO$_2-$Ar}
\label{subsec:example-correlation-co2-ar}

\subsection{Calculating a spectral function using $p_r/\mu$-representation for CO$_2-$Ar}
\label{subsec:example-prmu-co2-ar}

\subsection{Calculating an array of correlation functions for CO$_2-$Ar}
\label{subsec:example-correlation-array-co2-ar}


\section{Changelog}
\label{sec:changelog}

\begin{enumerate}
    \item [24.12.2024] \texttt{rhsMonomer}: accepts pointer so that monomer's \texttt{qp} can be changed if \texttt{apply\_requantization} flag is set.
    \item [06.01.2025] \texttt{Makefile}: switched to \texttt{Makefile} from build script.
    \item [08.01.2025] added MPI library which is hidden by the guard macro, implemented \texttt{mpi\_calculate\_M0}. Now the MPI and non-MPI versions of \texttt{hawaii.c} are compiled into two object files.  
    \item [09.01.2025] implemented \texttt{calculate\_correlation\_and\_save}. 
    \item [09.01.2025] Porting some of \texttt{hep}-functionality in \texttt{hep\_hawaii.cpp}. Zeroth moment can be calculated using adaptive Monte Carlo integration over phase space.
    \item [10.01.2025] Tracking the number of turning points is added to \texttt{correlation\_eval}.
    \item [10.01.2025] PES and its derivatives for CH$_4-$CO$_2$ are adapted.
    \item [11.01.2025] fixing error inverting momenta in \texttt{correlation\_eval}. Calculating correlation function for CO$_2-$Ar seems to be working correctly. Need to run a calculation with larger number of trajectories.
    \item [12.01.2025] added higher-order finite-difference formulas for differentiating energy: \texttt{compute\_numerical\_rhs} 
    \item [12.01.2025] trajectory for CH$_4-$CO$_2$ using kinetic energy only works correctly. Angles transformation and its jacobian needs to be adapted from FUNCHAL to account for different order of coordinates.
    \item [15.01.2025] Run calculation of correlation function for CO$_2-$Ar for 10.000.000 trajectories. The correlation function is in close agreement with the previous results. Now moving on to adapting code for processing correlation functions in \texttt{hawaii}.
    \item [17.01.2025] Adapted functions related to processing correlation function from FUNCHAL. Code implementing \texttt{loess} algorithm is left as-is because of the use of Eigen3.
    \item [19.01.2025] Added checks for NaN values of dipole in \texttt{correlation\_eval} to avoid the corruption of the correlation function estimate. At least one corrupted value of correlation function for CO$_2-$Ar  has occurred during the calculation of 10.000.000 trajectories. {\color{red} The reason for the occurence of the NaN is unknown. Should investigate when initial condition leading to NaN values is found.} Could this NaN be the consequence of overflow in \texttt{generate\_normal}?
    \item [19.01.2025] Implemented \texttt{calculate\_spectral\_function\_using\_prmu\_representation\_and\_save} function and tested that it produces correct result for CO$_2-$Ar at 300 K.
    \item [20.01.2025] Enable \texttt{switch-enum} option for compiler to invoke warning in the switch-cases where one of the cases of the enum is not explicitly handled even though default case is present. 
    \item [20.01.2025] Caught a possible (but really rare) overflow error in the implementation of Box-Mueller algorithm for sampling normally distributed variable: \texttt{generate\_normal}. 
    \item [20.01.2025] Estimate M$_0$ based on the spectral function obtained during each iteration of the pr-mu calculation
    \item [20.01.2025] Estimate M$_2$ using rejection sampling and using \texttt{hep}. Works for CO$_2-$Ar
    \item [22.01.2025] Trying out calculating correlation function for CO$-$Ar. {\color{red} Why is the error in M$_2$ is 13\% for 20.000.000 points?} 
    \item [25.01.2025] jacobian is working for CH$_4$-CO$_2$. \texttt{hawaii} is extended with function to compute numerical jacobian; analytical and numerical jacobians are in close agreement.
    \item [25.01.2025] fixed a bug in \texttt{extract\_q\_and\_write\_into\_ms} where coordinates for second monomer actually were overwriting the coordinates for the first monomer 
    \item [26.01.2025] adapted dipole function for CH$_4-$CO$_2$
    \item [26.01.2025] \texttt{examples/mpi\_phase\_space\_integration\_ch4\_co2} produces M$_0$ and M$_2$ spectral moments at 300 K which are consistent with previous estimations: M$_0$ =  $8.29 \cdot 10^{-4}$, M$_2$ = $5.37$. 
    \item [26.01.2025] differentiate between debug/release build in Makefile: apply separate compilation flags
    \item [27.01.2025] \texttt{examples/correlation\_ch4\_co2} produces what seems to be a correct spectrum, the spectral moments are in agreement with their phase-space counterparts.
    \item [27.01.2025] bug fix: desymmetrization procedure didn't propagate temperature to the output structure
    \item [31.01.2025] Implementing \texttt{calculate\_correlation\_array\_and\_save} that employs individual trajectory reweighting to produce results at satellite temperatures: testing on CO$_2-$Ar in \texttt{examples/correlation\_array\_co2\_ar}
    \item [01.02.2025] During the correlation and pr-mu calculations for CO$_2-$Ar on cluster, the file with temporary result is not written (at least for several iterations at the end of which the file is supposed to be written). Turns out that if stream is flushed using \texttt{fflush} and filesystem caches for a given file descriptor are forced to be committed to disk using \texttt{syncfs} the problem is resolved.
    \item [01.02.2025] \texttt{calculate\_correlation\_array\_and\_save} produces spectral profiles for CO$_2-$Ar (unbound states) that are in close agreement with the results obtained in 2021. Ensemble of approximately 8 million trajectories was used. {\color{red} Need to check for bound states as well.}
\end{enumerate}

\section{Todo's}

\begin{itemize}
    \item \texttt{mpi\_calculate\_M0}/\texttt{mpi\_calculate\_M2}: the temporary result is not accumulated over communicator, it is printed only for values accumulated only for zeroth process.
    \item Allow providing the value (values) of zeroth and second spectral moment to \texttt{calculate\_correlation\_and\_save} and \texttt{calculate\_correlation\_array\_and\_save}. {\color{red} For CH$_4-$CO$_2$ the calculation of second moments is time-consuming, so the values should probably be cached somehow.}
    \item How to organize and store the calculated results (cfs and sfs) for examples?
    \item Arena Allocator for storing some temporary strings and small arrays. At the moment, there are waaaay too many mallocs/frees. 
    \item Saving the contributions of free and metastable states in correlation function separately. How can we pass in the information about the desired filenames? How to organize the storage for these contributions? 
    \item The information about the number of turning points could be saved into gsl\_histogram, and then partially displayed in the output file and saved to file system
    \item We are using MPI\_Allreduce mechanism for broadcasting. This should be changed to direct MPI\_Send / MPI\_Recv calls.
    \item Can the \texttt{hawaii.h} file be used without constructing the MoleculeSystem? I moved code for processing correlation function there, but it can't be used without creating stubs for PES/dPES functions. Should \texttt{hawaii} create stubs when certain macro is in place? 
    \item Maybe we need a check that processes in the communicator get different seeds each?
    \item In case when correlation function is calculated for bound states, we can separate the contributions for bound-bound and bound-free transitions (Fakhardji trick)
    \item In case when correlation function is calculated for bound states, we should use the Zimmermann trick (use any point of trajectory as a 'starting point' of the correlation function). This should be the default approach for this correlation. 
    \item Adapt transforming angles between frames of reference for linear molecule-linear molecule
    \item How to organize Makefiles for use in different environments (several clusters)? If we push the changes to remote git repo on the remote machine, the local changes get overriden, thus removing the changes made to local Makefile. Annoying... 
    \item I would like to make a graphical shell in which it will be possible to set parameters for calculation (for example, in the form of a list with available options for each parameter). The program is given paths to files (or drag-and-dropped) with potential and dipole functions and it assembles an executable file. Here I make an assumption that it is better to have the potential to be statically compiled with the rest of the code rather than dynamically loading it from library. It would probably be nice to be able to run the trajectory program from graphical shell locally and display the calculation result. If the correlation function is calculated, then there is no need to add its processing within the same "stage". Let the correlation function be calculated separately, then the result should be loaded and converted into a spectrum. In the case of calculating the spectral function in the pr-mu representation, smoothing is also required, it is also carried out in a separate "stage". This would enable us to have a starting point for a graphical shell that can demonstrate some of the features of the library without overcomplicating from the very beginning. Later on, we could think about establishing TCP connection between shell and the main program running remotely enabling the user to setup the calculation with the desired parameters and monitor the calculation. 
\end{itemize}


\end{document}

