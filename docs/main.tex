\documentclass[color]{article}

\usepackage{amsmath}
\usepackage{graphicx} % Required for inserting images
\usepackage[dvipsnames]{xcolor}
\usepackage{hyperref}
\usepackage{xfrac}
\usepackage{booktabs}
\usepackage{rotating}
\usepackage{float}
\usepackage{enumitem} 

\usepackage{amssymb}

% longtable environment can be broken down by page break
\usepackage{longtable} 

\usepackage[margin=1in,top=0.5in]{geometry}

\usepackage{tikz}
\newcommand{\recttext}[1]{%
  \begin{tikzpicture}[baseline=(text.base)]
    \node[align=center, inner sep=0.35em] (text) {#1};
    \draw (text.south west) rectangle (text.north east);
  \end{tikzpicture}
}

\usepackage{biblatex}
\addbibresource{biblio.bib}
\DefineBibliographyStrings{english}{%
  bibliography = {References},
}

\newcommand{\lb}{\left(}
\newcommand{\rb}{\right)}
\newcommand{\lsq}{\left[}
\newcommand{\rsq}{\right]}
\newcommand{\mf}{\mathbf}
\newcommand*\diff{\mathop{}\!\mathrm{d}}
\newcommand{\intty}{\int\limits_{-\infty}^{+\infty}}

\newcommand{\libname}{\texttt{Hawaii Hybrid}\,}

\usepackage{listings}
\usepackage{xcolor} % For colored syntax highlighting

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{inputstyle}{
    backgroundcolor=\color{backcolour},   
    basicstyle=\ttfamily\small,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    commentstyle=\color{codegreen},
    escapeinside={\%*}{*)},          
    frame=single,
    keepspaces=true,                 
    keywordstyle=\color{blue},
    numbers=left,                    
    numberstyle=\tiny\color{codegray},
    rulecolor=\color{black},         
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    stringstyle=\color{codepurple},
    tabsize=2,
    % Custom keywords for your format
    morekeywords={
        INPUT, END, MONOMER, PAIR_STATE, CALCULATION_TYPE,
        TEMPERATURES, pair_reduced_mass, so_potential, so_dipole,
        sampler_Rmin, sampler_Rmax, hep_m0_npoints, hep_m0_niterations,
        MONOMER_TYPE, II
    },
    morecomment=[l]{!}, % Define ! as comment symbol
    morestring=[b]"     % Define strings in quotes
}

\title{Documentation for \libname v.0.1}
\author{A. Finenko and D. Chistikov}
\date{\today}

\begin{document}

\maketitle

\tableofcontents
\newpage 

\section{Problems addressed by library}
\label{sec:tasks}

\begin{enumerate}
\item Compute statistical averages over ensembles of classical trajectories restricted by chosen phase-space domains (e.g., bound or unbound states), enabling the calculation of dipole autocorrelation functions. 
\item Calculate static phase-space averages using rejection sampling and adaptive Monte Carlo algorithms to estimate zeroth and second spectral moments.
\item Transform correlation functions into spectral functions, apply smoothing, and convert them into spectral profiles.
\end{enumerate}


To ensure clarity, we will outline the key objects and their corresponding units of measurement. In the context of this document, the correlation function of the dipole moment, $C(t)$, is defined as:
\begin{gather}
    C(t) = V \langle \mu(0) \mu(t) \rangle.
\end{gather}
%
Note that this definition differs from others, such as the one in Ref. \cite{Chistikov2021}, as it does not include the 
$1/(4 \pi \varepsilon_0)$ factor. Instead, this factor is incorporated into the definition of the spectral function. The correlation function values are produced by \texttt{calculate\_correlation\_and\_save} and \texttt{calculate\_correlation\_array\_and\_save} in units of (m$^3 \cdot$ atomic unit of dipole). The time is treated internally in atomic time units, and the produced \texttt{CFnc} object stores the time in the atomic time units. However, when the correlation function is to be processed in order to be converted into spectral function (by \texttt{fit\_baseline} function), time axis needs to be in seconds.

The spectral function is defined as follows:
\begin{gather}
    G(\nu) = \frac{1}{2\pi} \frac{1}{4\pi \varepsilon_0} \intty C(t) e^{-2 \pi i c \nu t} \diff{t},
\end{gather}
%
where $\nu$ is the wavenumber (cm$^{-1}$). The values of spectral function are $\text{J} \cdot \text{m}^6 \cdot \text{s} = \text{kg} \cdot \text{m}^8 \cdot \text{s}$. 

The binary absorption coefficient is then related to the spectral function according to:
\begin{gather}
    \alpha(\nu) = \frac{\tau(\nu)}{\rho_1 \rho_2} = \frac{(2\pi)^4 N_L^2}{3 h} \nu \lsq 1 - \exp \lb -\frac{h c \nu}{k_\text{B} T} \rb \rsq G(\nu),
\end{gather}
%
where the absorption coefficient is
\begin{gather}
    \tau(\nu) = L^{-1} \ln (I_0 / I),
\end{gather}
%
and $\rho_1$ and $\rho_2$ are gas densities in mixture. We will express the binary absorption coefficient as per convention in cm$^{-1}$Amagat$^{-2}$.

\section{Input file format}
\label{sec:input-file-format}

This section provides an overview of the input file format, including its structures, features, and supported data types.
The format uses \texttt{\&SECTION\_NAME} and \texttt{\&END} delimiters to define sections containing case-insensitive key-value pairs (assigned with \texttt{=}) or function calls. Comments are indicated with  exclamation marks \texttt{!} throughout the input file. The input file parser enforces type safety, requiring each key to have a value of the expected type; any type mismatch triggers an error message and terminates program execution. \\

\noindent
Supported data types include integers, floating-point values, boolean values, strings and arrays. Underscores may be used in integers for readability (e.g., \texttt{1\_000\_000}). For floating point values the scientific notation may be used (e.g., \texttt{1e2} instead of \texttt{100}). The arrays are denoted with curly braces \texttt{\{\}}.  
\\

\noindent
\texttt{\&INPUT} section provides overall control of the calculation, for example, calculation type, pair state, reduced mass, paths to dynamic libraries containing potential energy and induced dipole functions, and output files. The available input parameters are described in Section \ref{subsec:input-section}. \\  

\noindent
\texttt{\&MONOMER} section specifies the types of interacting monomers through the \texttt{MONOMER\_TYPE} field along with their molecular constants such as inertia tensor values and centrifugal constant. The available paramters are listed in Section \ref{subsec:monomer-section}. \\

\noindent
\texttt{\&PROCESSING} section configures the data pipeline using a stack machine model, where each command manipulates the implicit data stack. Unlike the \texttt{\&INPUT} and \texttt{\&MONOMER} sections, the \texttt{\&PROCESSING} section also contains an order-sensitive sequence of commands that execute sequentially, consuming inputs from the top of the stack and pushing the results back for subsequent commands. A typical pipeline begins with loading data using \texttt{read\_cf}, which pushes a correlation function onto the stack. Then \texttt{cf\_to\_sf} consumes the correlation function and pushes corresponding spectral function. Commands like \texttt{compute\_m0\_classical\_detailed\_balance} and \texttt{compute\_m2\_classical\_detailed\_balance} consume the spectral function, requiring the user to first call \texttt{dup()} to preserve the original spectral function if further commands will be operating on it. By the end of the processing script, the stack must be empty, ensuring all data has been processed or saved. The available functions are described in Section \ref{subsec:processing-section}. \\

\subsection{\texttt{INPUT} section}
\label{subsec:input-section}

Here we provide a detailed description of keywords handled in the \texttt{INPUT} block.

\begin{table}[H]
  \begin{tabular}{ll}
    \texttt{\#1} & \texttt{CALCULATION\_TYPE} \\
    \texttt{\#2} & \texttt{PAIR\_STATE} \\
    \texttt{\#3} & \texttt{PAIR\_REDUCED\_MASS} \\
    \texttt{\#4} & \texttt{SO\_POTENTIAL} \\
    \texttt{\#5a} & \texttt{SO\_DIPOLE} \\
    \texttt{\#5b} & \texttt{SO\_DIPOLE.1} \\
    \texttt{\#5c} & \texttt{SO\_DIPOLE.2} \\
    \texttt{\#6} & \texttt{TEMPERATURE} \\
    \texttt{\#7} & \texttt{TEMPERATURES} \\
    \texttt{\#8} & \texttt{SATELLITE\_TEMPERATURES} \\
    \texttt{\#9} & \texttt{TOTAL\_TRAJECTORIES} \\
    \texttt{\#10} & \texttt{CVODE\_TOLERANCE} \\
    \texttt{\#11} & \texttt{SAMPLING\_TIME} \\
    \texttt{\#12} & \texttt{MAXTRAJECTORYLENGTH} \\
    \texttt{\#13} & \texttt{SAMPLER\_RMIN} \\
    \texttt{\#14} & \texttt{SAMPLER\_RMAX} \\
    \texttt{\#15} & \texttt{PESMIN} \\
    \texttt{\#16} & \texttt{INITIALM0\_NPOINTS} \\
    \texttt{\#17} & \texttt{INITIALM2\_NPOINTS} \\
    \texttt{\#18} & \texttt{HEP\_M0\_NPOINTS} \\
    \texttt{\#19} & \texttt{HEP\_M0\_NITERATIONS} \\
    \texttt{\#20} & \texttt{HEP\_M2\_NPOINTS} \\
    \texttt{\#21} & \texttt{HEP\_M2\_NITERATIONS} \\
    \texttt{\#22} & \texttt{HEP\_PPF\_NITERATIONS} \\
    \texttt{\#23} & \texttt{HEP\_PPF\_NPOINTS} \\
    \texttt{\#24} & \texttt{SF\_FILENAME} \\
    \texttt{\#25} & \texttt{CF\_FILENAME} \\
    \texttt{\#26} & \texttt{CF\_FILENAMES} \\
    \texttt{\#27} & \texttt{R0} \\
    \texttt{\#28} & \texttt{RCUT} \\
    \texttt{\#29} & \texttt{PARTIAL\_PARTITION\_FUNCTION\_RATIO} \\
    \texttt{\#30} & \texttt{PARTIAL\_PARTITION\_FUNCTION\_RATIOS} \\
    \texttt{\#31} & \texttt{APPROXIMATEFREQUENCYMAX} \\
    \texttt{\#32} & \texttt{ODD\_J\_SPIN\_WEIGHT} \\
    \texttt{\#33} & \texttt{EVEN\_J\_SPIN\_WEIGHT} \\
    \texttt{\#34} & \texttt{USE\_ZIMMERMANN\_TRICK} \\
    \texttt{\#35} & \texttt{AVERAGE\_TIME\_BETWEEN\_COLLISIONS} \\
  \end{tabular}
\end{table}

\noindent
\texttt{\#1. CALCULATION\_TYPE}. The program performs calculations based on the specified \texttt{CALCULATION\_TYPE}. This field is required and expected to be a plain string (no quotation marks). Note that there is no default value - the field must be explicitly provided. Supported calculation types:

\begin{enumerate}[itemsep=-3pt]
    \item \texttt{CALCULATION\_PR\_MU} 
    \item \texttt{CALCULATION\_CORRELATION\_SINGLE} 
    \item \texttt{CALCULATION\_CORRELATION\_ARRAY}
    \item \texttt{CALCULATION\_PROCESSING} 
    \item \texttt{CALCULATION\_PHASE\_SPACE\_M0}
    \item \texttt{CALCULATION\_PHASE\_SPACE\_M2}
\end{enumerate}

\noindent
\texttt{\#2. PAIR\_STATE}. The pair state is specified using the keyword \texttt{PAIR\_STATE} as a plain string (no quotation marks). This field is required, no default value is implied. This parameter is applicable for all calculation types except for \texttt{CALCULATION\_PROCESSING}, where it's ignored. Available pair states: 

\begin{enumerate}[itemsep=-3pt]
    \item \texttt{FREE\_AND\_METASTABLE}
    \item \texttt{BOUND}
    \item \texttt{ALL}
\end{enumerate}

\noindent
\texttt{\#3. PAIR\_REDUCED\_MASS}. The reduced mass for a pair is specified as a floating-point number. This parameter is applicable for all calculation types except for \texttt{CALCULATION\_PROCESSING}. \\

\noindent
\texttt{\#4. SO\_POTENTIAL} specifies a double-quoted string path to a dynamic library containing the required symbols \texttt{double pes\_lab(double* )} and \texttt{void dpes\_lab(double*, double*)}. Missing symbols trigger immediate termination. Functions \texttt{pes\_lab} and \texttt{dpes\_lab} operate on laboratory-frame coordinates and compute the potential energy and its derivative (outputted through the second pointer), respectively. If present, a symbol \texttt{void pes\_init(void)} will be executed before any calls \texttt{pes\_lab} and \texttt{dpes\_lab} will be issued, enabling library initialization (e.g., loading the parameters from file). \\

\noindent
\texttt{\#5a. SO\_DIPOLE} specifies a double-quoted string path to a dynamic library implementing the required symbol \texttt{void dipole\_lab(double *, double [3])}, which computes laboratory-frame dipole moment components from input coordinates in the laboratory frame of reference. Missing symbol trigger immediate termination. The loaded function is assigned to \texttt{dipole\_1} and \texttt{dipole\_2}, enabling calculation of autocorrelation functions. if present, a symbol \texttt{void dipole\_init(void)} will be executed before any calls \texttt{dipole\_lab} will be issued, enabling library initialization. This setting  is equivalent to assigning the same path to both \texttt{SO\_DIPOLE.1} and \texttt{SO\_DIPOLE.2}. \\

\noindent
\texttt{\#5b, c. SO\_DIPOLE.1, SO\_DIPOLE.2} specify independent paths to dipole function implementations as dynamic libraries. The required and optional symbols match those mentioned in \texttt{\#5.a}. Setting these paths to different dynamic libraries enables the calculation of mixed correlation correlation. \\ 

\noindent
\texttt{\#6. TEMPERATURE}

\subsection{\texttt{MONOMER} section}
\label{subsec:monomer-section}

Here we provide a detailed description of keywords handled in the \texttt{MONOMER} block.

\begin{table}[H]
  \begin{tabular}{ll}
    \texttt{\#36} & \texttt{MONOMER\_TYPE} \\
    \texttt{\#37} & \texttt{DJ} \\
    \texttt{\#38} & \texttt{II} \\
    \texttt{\#39} & \texttt{INITIAL\_J} \\
    \texttt{\#40} & \texttt{TORQUE\_CACHE\_LEN} \\
    \texttt{\#41} & \texttt{TORQUE\_LIMIT} \\
    \texttt{\#42} & \texttt{NSWITCH\_HISTOGRAM\_BINS} \\
    \texttt{\#43} & \texttt{NSWITCH\_HISTOGRAM\_MAX} \\
    \texttt{\#44} & \texttt{NSWITCH\_HISTOGRAM\_FILENAME} \\
    \texttt{\#45} & \texttt{JINI\_HISTOGRAM\_BINS} \\
    \texttt{\#46} & \texttt{JINI\_HISTOGRAM\_MAX} \\
    \texttt{\#47} & \texttt{JINI\_HISTOGRAM\_FILENAME} \\
    \texttt{\#48} & \texttt{JFIN\_HISTOGRAM\_BINS} \\
    \texttt{\#49} & \texttt{JFIN\_HISTOGRAM\_MAX} \\
    \texttt{\#50} & \texttt{JFIN\_HISTOGRAM\_FILENAME} \\
  \end{tabular}
\end{table}

\subsection{\texttt{PROCESSING} section}
\label{subsec:processing-section}

Here we provide a detailed description of keywords 
%
\begin{table}[H]
  \begin{tabular}{ll}
    \texttt{\#51} & \texttt{SPECTRUM\_FREQUENCY\_MAX}
  \end{tabular}
\end{table}
%
and internal functions handled in the \texttt{MONOMER} block.
%
\begin{table}[H]
  \begin{tabular}{ll}
    \texttt{\#52} & \texttt{READ\_CF(\textbackslash 1)} \\
    \texttt{\#53} & \texttt{DUP()} \\
    \texttt{\#54} & \texttt{INT3()} \\
    \texttt{\#55} & \texttt{AVERAGE\_CFS()} \\
    \texttt{\#56} & \texttt{COMPUTE\_M0\_CLASSICAL\_DETAILED\_BALANCE()} \\
    \texttt{\#57} & \texttt{COMPUTE\_M2\_CLASSICAL\_DETAILED\_BALANCE()} \\
    \texttt{\#58} & \texttt{FIT\_BASELINE()} \\
    \texttt{\#59} & \texttt{CF\_TO\_SF()} \\
    \texttt{\#60} & \texttt{ALPHA()} \\
    \texttt{\#61} & \texttt{D3()} \\
    \texttt{\#62} & \texttt{WRITE\_CF(\textbackslash 1)} \\
    \texttt{\#63} & \texttt{WRITE\_SF(\textbackslash 1)} \\
    \texttt{\#64} & \texttt{WRITE\_SPECTRUM(\textbackslash 1)} \\
  \end{tabular}
\end{table}

\section{Examples}
\label{sec:serial-examples}

\begin{table}[!ht]
  \centering
  \begin{tabular}{ccccc}
    \toprule
              & \rotatebox{70}{trajectory} & \rotatebox{70}{phase-space moments} & \rotatebox{70}{single correlation function} & \rotatebox{70}{array of correlation functions} \\
    \midrule
    He-Ar & {\color{ForestGreen}\checkmark} & {\color{ForestGreen}\checkmark} & {\color{ForestGreen}\checkmark} &{\color{red}$\times$} \\ 
    CO$-$Ar & {\color{red}$\times$} & {\color{red}$\times$} & {\color{ForestGreen}\checkmark} & {\color{red}$\times$} \\
    CO$_2-$Ar & {\color{ForestGreen}\checkmark} & {\color{ForestGreen}\checkmark} & {\color{ForestGreen}\checkmark} & {\color{ForestGreen}\checkmark} \\
    N$_2-$Ar & {\color{red}$\times$} & {\color{ForestGreen}\checkmark} & {\color{ForestGreen}\checkmark} & {\color{ForestGreen}\checkmark} \\ 
    H$_2-$Ar & {\color{ForestGreen}\checkmark} &  {\color{red}$\times$}  &  {\color{red}$\times$} &  {\color{red}$\times$}  \\  
    CH$_4-$CO$_2$ & {\color{ForestGreen}\checkmark} & {\color{ForestGreen}\checkmark} & {\color{ForestGreen}\checkmark} & {\color{ForestGreen}\checkmark} \\
    \bottomrule
  \end{tabular}
\end{table}

\subsection{Propagating trajectory for CO$_2-$Ar}
\label{subsec:example-trajectory}

As an initial illustration of the use of \libname package, we give a sample program called \texttt{trajectory\_co2\_ar.cpp} to propagate a trajectory of collisional dynamics of CO$_2-$Ar system. The problem consists of solving the following Hamilton dynamical equations:

\begin{align*}
    \dot{R} &= \frac{p_R}{m}, \\
    \dot{p}_R &= \frac{p_\Theta^2}{m R^3} + \frac{p_\Phi^2}{m R^3 \sin^2 \Theta} - \frac{\partial U}{\partial R}, \\
    \dot{\Phi} &= \frac{p_\Phi}{m R^2 \sin^2 \Theta}, \\
    \dot{p}_\Phi &= -\frac{\partial U}{\partial \Phi}, \\
    \dot{\Theta} &= \frac{p_\Theta}{m R^2}, \\
    \dot{p}_\Theta &= \frac{p_\Phi^2 \cos \Theta}{m R^2 \sin^3 \Theta} - \frac{\partial U}{\partial \Theta}, \\
    \dot{\varphi}_1 &= \frac{\displaystyle p_1^{\varphi}}{I_1 \sin^2 \vartheta_1}, \\
    \dot{p}_1^{\varphi} &= -\frac{\partial U}{\partial \varphi_1}, \\
    \dot{\vartheta}_1 &= \frac{p_1^\vartheta}{I_1}, \\ 
    \dot{p}_1^{\theta} &= \frac{\displaystyle \lb p_1^\varphi \rb^2 \cos \theta_1}{I_1 \sin^3 \theta_1} - \frac{\partial U}{\partial \theta_1}.
\end{align*}
%
The \texttt{hawaii.h} header files provides definition of the struct \texttt{MoleculeSystem} that is used to evaluate the right-hand side of the dynamical equations. The \texttt{trajectory.h} header provides struct \texttt{Trajectory} that provides interface with \texttt{CVode} library that performs the integration of dynamical equations (see Section~\ref{subsec:cvode}).
Next, we provide implementations for functions that calculate potential energy \texttt{pes} and its derivatives with respect to coordinates \texttt{dpes}. Each user program that instantiates the \texttt{MoleculeSystem} is expected to implement these functions. To implement these functions \texttt{hawaii} provides functions to transform angles between different reference frames (see Section~\ref{subsec:angle-transformation}).      


\subsection{Propagating trajectory for H$_2-$Ar while requantizing the angular momentum of H$_2$}
\label{subsec:example-req-trajectory}

\subsection{Calculating the zeroth and second spectral moments of CO$_2-$Ar as phase-space averages using rejection-based sampler}
\label{subsec:example-spmoments-co2-ar}

This example demonstrates how to use interface with \texttt{hep} to calculate spectral moments. 
First, the zeroth moment over unbound states is calculated as follows:
\begin{gather}
    M_0 = \frac{(2 \pi)^4 N_L^2}{3 (Q/V) h} \frac{1}{4 \pi \epsilon_0} \frac{1}{2 \pi c} \int\limits_{\Omega: H > 0} \mu^2 \exp \lb -\frac{H}{kT} \rb \diff{\mf{q}} \diff{\mf{p}}. \notag
\end{gather}
%
The integral is evaluated using \texttt{mpi\_perform\_integration}, whereas the partition can be calculated using \texttt{analytic\_full\_partition\_function\_by\_V}.    


\subsection{Calculating a single correlation function for CO$_2-$Ar}
\label{subsec:example-correlation-co2-ar}

\subsection{Calculating a spectral function using $p_r/\mu$-representation for CO$_2-$Ar}
\label{subsec:example-prmu-co2-ar}

\subsection{Calculating an array of correlation functions for CO$_2-$Ar}
\label{subsec:example-correlation-array-co2-ar}

\subsection{Processing correlation function for CO$_2-$Ar}
\label{subsec:example-processing}


\section{Complete list of function and code organization}
\label{sec:code-organization}


\subsection{Setting up a molecule pair}
\label{subsec:module-hawaii}


\recttext{\texttt{enum MonomerType}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Values & \texttt{ATOM = 0} \\
           & \texttt{LINEAR\_MOLECULE = 4} \\
           & \texttt{LINEAR\_MOLECULE\_REQ\_INTEGER = MODULO\_BASE + 4} \\
           & \texttt{LINEAR\_MOLECULE\_REQ\_HALFINTEGER = 2*MODULO\_BASE + 4} \\
           & {\color{red} \texttt{/* LINEAR\_VIBRATING\_MOLECULE = MODULO\_BASE + 6 */}} \\
           & \texttt{ROTOR = 6} \\
           & \texttt{ROTOR\_REQUANTIZED\_ROTATION = 2*MODULO\_BASE + 6} \\
    Description & This enum is used to distinguish between systems of different types and store the size of the phase point: \texttt{size(phase\_point) = MonomerType \% MODULO\_BASE}, where \texttt{MODULO\_BASE} is \texttt{\#define}d to 100 by default. 
\end{longtable} 

\noindent 
\recttext{\texttt{struct Monomer}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Fields & \texttt{MonomerType t} \\
           &  \texttt{double I[3]} -- values of tensor of inertia \\
           & \texttt{double DJ} -- centrifugal distortion constant \\
           &  \texttt{double *qp} -- dynamic variables  {\color{red} (currently, Euler angles and conjugated momenta)} at the current step of simulation\\
           & \texttt{double *dVdq} -- the derivatives of potential energy with respect to coordinates pertaining to this monomer (the order of coordinates is the same as for \texttt{qp}) \\
           &  \texttt{bool apply\_requantization} \\
    Description & The \texttt{apply\_requantization} will be set to \texttt{true} in \texttt{rhs} to signal that the requantization of the monomer's angular momentum is required during trajectory propagation.  
    The order of variables in the \texttt{qp} array is specified by the following indices: \\
    & \texttt{\#define IPHI 0} \\
    & \texttt{\#define IPPHI 1} \\
    & \texttt{\#define ITHETA 2} \\
    & \texttt{\#define IPTHETA 3} \\
    & \texttt{\#define IPSI 4} \\
    & \texttt{\#define IPPSI 5} \\
\end{longtable} 


\noindent
\recttext{\texttt{enum PairState}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Values & \texttt{FREE\_AND\_METASTABLE} = 0 \\
           & \texttt{BOUND} = 1 \\
    Description & \\ 
\end{longtable} 

\noindent
\recttext{\texttt{struct MoleculeSystem}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Fields & \texttt{double intermolecular\_qp[6]} -- Coordinates and conjugated momenta that correspond to the intermolecular motion: ($\Phi$, $p_\Phi$, $\Theta$, $p_\Theta$, $R$, $p_R$). \\
           & \texttt{Monomer m1} \\
           & \texttt{Monomer m2} \\
           & \texttt{double mu} -- reduced mass of molecule pair \\
           & \texttt{size\_t Q\_SIZE} -- total number of coordinates for molecule pair \\
           & \texttt{size\_t QP\_SIZE} -- total number of coordinates and momenta for molecule pair (a.k.a. \texttt{size(phase\_point)}) \\
           & \texttt{double *intermediate\_q} -- contiguous vector of coordinates \\
           & \texttt{double *dVdq} -- contiguous vector of potential energy derivatives  \\
           & \texttt{time\_t init\_rawtime} -- the initialization time, represented as the number of seconds since the Unix Epoch; set in \texttt{init\_ms} \\
           & \texttt{time\_t temp\_rawtime} -- a temporary time field for the time at which the previous iteration was completed, used for tracking elapsed time between iterations \\

    Description &  Keep in mind that angular variables and momenta are stored in the same order as for \texttt{qp} in \texttt{Monomer}. These variables' locations are \texttt{\#define}d as follows: \\
    &  \texttt{\#define IPHI 0} \\
    & \texttt{\#define IPPHI 1} \\
    & \texttt{\#define ITHETA 2} \\
    & \texttt{\#define IPTHETA 3} \\
    & \texttt{\#define IR 4} \\
    & \texttt{\#define IPR 5} \\
    & Keep in mind that intermolecular coordinates and monomer's coordinates are not stored contiguously. The contiguous vector of coordinates can be assembled by calling \texttt{extract\_q\_and\_write\_into\_ms} function, which stores the coordinates in memory pointed at by \texttt{intermediate\_q}. These coordinates are passed to external functions that compute the values of intermolecular energy, its derivatives with respect to coordinates and induced dipole (see section~\ref{subsec:external-functions}).There is no guarantee that coordinates stored in \texttt{Monomer}'s and coordinates in memory at \texttt{intermediate\_q} are always in sync.  The function \texttt{extract\_q\_and\_write\_into\_ms} must be invoked if the contiguous vector of coordinates is desired at a certain point of the program execution. 
\end{longtable} 

\noindent 
Function \recttext{\texttt{init\_ms}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{MoleculeSystem *ms = MoleculeSystem init\_ms(mu, t1, t2, I1, I2, seed)} \\
    Arguments & \texttt{double mu} -- the reduced mass of the molecule pair \\
              & \texttt{MonomerType t1} specifies the type of first monomer \\ 
              & \texttt{MonomerType t2} specifies the type of second monomer \\
              & \texttt{double* I1} contains inertia tensor values for first monomer. If the monomer is atom, no values will be read from the pointer, so \texttt{NULL} can be passed. Two and three values are expected for the rotor and linear molecule, respectively. \\
              & \texttt{double* I2} contains inertia tensor values for second monomer. \\
              & \texttt{size\_t seed} is the seed for random number generator. A unique seed will be produced if \texttt{0} is passed. \\
    Description & The function prepares the \texttt{MoleculeSystem} struct based on the specified monomer types, {\color{red} allocates the memory using \texttt{malloc}} (probably should be avoided due to cache locality) and initializes the random number generator. 
\end{longtable} 

\noindent
Function \recttext{\texttt{kinetic\_energy}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{double kinetic\_energy(*ms)} \\
    Arguments & \texttt{MoleculeSystem* ms} \\
    Description & The kinetic energy function is calculated at the phase-point stored in \texttt{MoleculeSystem}. {\color{red} Currently, implemented for intermolecular degrees of freedom, linear molecule (tested) and rotor (tested).}
    Parts of the kinetic energy corresponding to intermolecular degrees of freedom: 
    \begin{gather}
        \displaystyle T_\textrm{int} = \frac{p_R^2}{2 \mu} + \frac{p_\Theta^2}{2 \mu R^2} + \frac{p_\Phi^2}{2\mu R^2 \sin^2 \Theta}; \notag
    \end{gather}
    %
    to linear molecule:
    \begin{gather}
        \displaystyle T_\textrm{lin} = \frac{p_\theta^2}{2 I} + \frac{p_\varphi^2}{2 I \sin^2 \theta}; \notag
    \end{gather}
    to rotor:
    \begin{gather}
        \displaystyle T_\textrm{rotor} = \frac{1}{2 I_1 \sin^2 \theta_2} \Big[ \lb p_\varphi - p_\psi \cos \theta \rb \sin \psi + p_\theta \sin \theta \cos \psi \Big]^2 + \notag \\ 
        \displaystyle + \frac{1}{2 I_2 \sin^2 \theta} \Big[ \lb p_\varphi - p_\psi \cos \theta \rb \cos \psi - p_\theta \sin \theta \sin \psi \Big]^2 + \frac{1}{2 I_3} \lb p_\psi \rb^2. \notag 
    \end{gather}
\end{longtable}

\noindent
Function \recttext{\texttt{Hamiltonian}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{double Hamiltonian(*ms)} \\
    Arguments & \texttt{MoleculeSystem* ms} \\
    Description & Calls to \texttt{kinetic energy}, assembles a contiguous vector of coordinates via \texttt{extract\_q\_and\_write\_into\_ms} and passes it to external \texttt{pes}. 
\end{longtable} 

The potential energy and its derivatives are expected to be provided as functions with the following signatures:   

\noindent
Function \recttext{\texttt{pes}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{double pes(*q);} \\
    Arguments & \texttt{double *q} \\
    Description & An array of \texttt{Q\_SIZE} variables is passed to this function; \texttt{MoleculeSystem} describes their order. Intermolecular distance measured in Bohrs, while angles are measured in radians. The function is expected to return energy in Hartree.
\end{longtable}

\noindent
Function \recttext{\texttt{dpes}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void dpes(*q, *dpesdq);} \\
    Arguments & \texttt{double *q} \\
              & \texttt{double *dpesdq} \\
    Description & An array of \texttt{Q\_SIZE} variables is passed to this function; \texttt{MoleculeSystem} describes their order. Intermolecular distance measured in Bohrs, while angles are measured in radians. The function is expected to return an array of derivatives of energy in units of Hartree/Bohr of length \texttt{Q\_SIZE}.
\end{longtable}

\noindent
Function \recttext{\texttt{dipole}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void dpes(*q, *dpesdq);} \\
    Arguments & \texttt{double *q} \\
              & \texttt{double *dpesdq} \\
    Description &
\end{longtable}

\texttt{pes} and \texttt{dpes} are defined as external functions in the header \texttt{hawaii.h}, so they have to be implemented in the user program, whereas the dipole function needs to be set through function pointer named \texttt{dipole}. 

%\noindent
%\recttext{\texttt{enum CalculationType}} \vspace*{-0.25em}
%\begin{longtable}{lp{15cm}}
%    Values & \texttt{PRMU} = 0 \\
%           & \texttt{CORRELATION\_SINGLE} = 1 \\
%           & \texttt{CORRELATION\_ARRAY} = 2 \\
%    Description & \\ 
%\end{longtable} 


\subsection{Sampling the phase-space point}


\noindent
Function \recttext{\texttt{q\_generator}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void q\_generator(*ms, *params)} \\
    Arguments & \texttt{MoleculeSystem* ms} \\
              & \texttt{CalcParams *params} \\
    Description & Generates $R$ with density $\rho \sim R^2$ in the range [\texttt{params.sampler\_Rmin}, \texttt{params.sampler\_Rmax}]. The distributions of $\varphi, \psi$ are $\varphi, \psi \sim U[0, 2\pi]$ and for $\theta$ is $\cos \theta \sim U[0, 1]$. Implemented for intermolecular degrees of freedom, linear molecule and rotor.
\end{longtable} 

\noindent
Function \recttext{\texttt{p\_generator}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void p\_generator(*ms, T)} \\
    Arguments & \texttt{MoleculeSystem* ms} \\
              & \texttt{double T} \\
    Description & Samples momenta $p$ from distribution $\rho \sim e^{-K/kT}$ at given temperature. Switches between \texttt{p\_generator\_linear\_molecule} and \texttt{p\_generator\_rotor} to sample momenta for monomers.
\end{longtable} 

\noindent
Function \recttext{\texttt{reject}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{bool reject(*ms, Temperature, pesmin)} \\
    Arguments & \texttt{MoleculeSystem* ms} \\
              & \texttt{double Temperature} \\
              & \texttt{double pesmin} -- the minimum value of PES \\
    Description & Applies the rejection step to the phase-point that is stored in the \texttt{MoleculeSystem}. It presupposes that the provided phase-point is sampled from $\rho \sim e^{-K/kT}$ using \texttt{q\_generator} and \texttt{p\_generator} functions. The random variable $u \sim U[0, 1]$ is chosen, to determine whether the current phase-point is to be accepted with probability $\rho \sim \exp(-H/kT)$.     
\end{longtable} 

\subsection{Calculating a trajectory: interfacing with \texttt{CVode} library}
\label{subsec:trajectory}

\noindent
\recttext{\texttt{struct Trajectory}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Fields & \texttt{size\_t DIM} \\
           & \texttt{size\_t mxsteps} \\
           & \texttt{N\_Vector y} \\
           & \texttt{N\_Vector abstol} \\
           & \texttt{N\_Vector reltol} \\
           & \texttt{SUNMatrix A} \\
           & \texttt{SUNLinearSolver LS} \\
           & \texttt{void *cvode\_mem} \\
    Description & 
\end{longtable}

\noindent
Function \recttext{\texttt{init\_trajectory}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{Trajectory init\_trajectory(*ms, *transformed, reltol);} \\
    Arguments & \texttt{MoleculeSystem *ms} \\
              & \texttt{double reltol} \\
    Description & 
\end{longtable}

\noindent
Function \recttext{\texttt{free\_trajectory}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void free\_trajectory(*traj);} \\
    Arguments & \texttt{Trajectory *traj} \\
    Description & 
\end{longtable}

\noindent
Function \recttext{\texttt{reinit\_trajectory}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void reinit\_trajectory(*traj, t);} \\
    Arguments & \texttt{Trajectory *traj} \\
              & \texttt{double t} \\
    Description & 
\end{longtable}

\noindent
Function \recttext{\texttt{make\_step}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{int make\_step(*traj, tout, *t);} \\
    Arguments & \texttt{Trajectory *traj} \\
              & \texttt{double tout} \\
              & \texttt{double *t} \\
    Description & Invokes the CVode main function and, if enabled, applies requantization to the monomers' angular momenta.
    When the \texttt{apply\_requantization} flag is set, the momenta in \texttt{qp} are rescaled to adjust the angular momentum to the nearest half-integer or integer, according to the requantization rule which is represented with the Monomer type. Subsequently, the function synchronizes the internal \texttt{trajectory} phase-space vector with the \texttt{MoleculeSystem} phase-space vector, and reinitializes the state of CVode to reset its state since a sudden change of phase-point has occured.
\end{longtable}

\noindent
Function \recttext{\texttt{set\_initial\_condition}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void set\_initial\_condition(*traj, qp);} \\
    Arguments & \texttt{Trajectory *traj} \\
              & \texttt{Array qp} \\
    Description & 
\end{longtable}

\noindent
Function \recttext{\texttt{make\_vector}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{N\_Vector make\_vector(size);} \\
    Arguments & \texttt{int size} \\
    Description & 
\end{longtable}

\noindent
Function \recttext{\texttt{set\_tolerance}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void set\_tolerance(*traj, tolerance);} \\
    Arguments & \texttt{Trajectory *traj} \\
              * \texttt{double tolerance} \\
    Description & 
\end{longtable}


\noindent
Function \recttext{\texttt{rhs}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void rhs(t, y, ydot, *user\_data);} \\
    Arguments & \texttt{UNUSED(realtype t)} \\
              & \texttt{N\_Vector y} stores coordinates and conjugated momenta \\
              & \texttt{N\_Vector ydot} is filled by function with numerical values of right-hand side of Hamilton's equations of motion  at provided phase point \\
              & \texttt{void *user\_data} is employed to pass \texttt{MoleculeSystem*} inside the function (see section \ref{subsec:cvode}) \\
    Description & This function is passed to \texttt{CVode} library to propagate the trajectory (see section \ref{subsec:cvode}).First, the phase-point coordinates are stored into \texttt{MoleculeSystem} struct. A contiguous vector of coordinates is assembled via \texttt{extract\_q\_and\_write\_into\_ms}. Next, by calling the external function \texttt{dpes}, the derivatives of potential energy are computed  and stored into \texttt{MoleculeSystem.dVdq}. The components of derivative vector are then copied into the field \texttt{Monomer.dVdq} of the corresponding monomer via the call to \texttt{extract\_dVdq\_and\_write\_into\_monomers}. The right-hand side of Hamilton's equations with respect to intermolecular degrees of freedom are readily obtained and filled into \texttt{ydot}, while the derivatives with respect to monomer's coordinates are handled by \texttt{rhsMonomer} function.
\end{longtable} 

\noindent
Function \recttext{\texttt{rhsMonomer}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void rhsMonomer(*m, *deriv);} \\
    Arguments & \texttt{Monomer *m} \\
              & \texttt{double *deriv} stores the right-hand side of Hamilton's equations of motion with respect to coordinates and momenta that correspond to the passed-in monomer \\
    Description &  In addition to differentiating the kinetic energy, the derivatives of potential energy, which are taken from \texttt{Monomer.dVdq}, are also added to compute the right-hand side.  
    {\color{red} Implemented for cases of LINEAR\_MOLECULE (tested) and ROTOR (tested).}
\end{longtable} 

\noindent
Function \recttext{\texttt{compute\_numerical\_rhs}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{Array compute\_numerical\_rhs(*ms, order);} \\
    Arguments & \texttt{MoleculeSystem *ms} \\
              & \texttt{size\_t order} -- the order of the central finite-difference formula (implemented for 2, 4 or 6) \\
    Description &  Computes numerically the right-hand side of the Hamiltonian equations of motion. The order corresponds to the order of variables employed in MoleculeSystem struct. 
\end{longtable}

\subsection{Conducting angular momentum requantization}

\noindent
Function \recttext{\texttt{j\_monomer}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void j\_monomer(m, j);} \\
    Arguments & \texttt{Monomer m} \\
              & \texttt{double j[3]} \\
    Description &  Computes the magnitude of angular momentum of passed-in monomer. {\color{red} Currently, implemented only for linear molecules.} 
    \begin{gather}
        [\textrm{linear molecule}]: j = \begin{bmatrix}
          - p_\theta \sin \varphi - p_\varphi \cos \varphi / \tan \theta \\
          p_\theta \cos \varphi - p_\varphi \sin \varphi / \tan \theta \\
          p_\varphi
        \end{bmatrix} \notag
    \end{gather}
\end{longtable}

\noindent
Function \recttext{\texttt{torque\_monomer}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{double torque\_monomer(m);} \\
    Arguments & \texttt{Monomer m} \\
    Description &  Computes the magnitude of torque of passed-in monomer. Needs the derivative of potential \texttt{m.dVdq} to be set within the monomer. {\color{red} Currently, implemented only for linear molecules.}
    \begin{gather}
        [\textrm{linear molecule}]: \tau = \begin{bmatrix}
            \displaystyle \sin \varphi \frac{\diff{V}}{\diff{\theta}} + \cos \varphi / \tan \theta \frac{\diff{V}}{\diff{\varphi}} \\
            \displaystyle -\cos \varphi \frac{\diff{V}}{\diff{\theta}} + \sin \varphi / \tan \theta \frac{\diff{V}}{\diff{\varphi}} \\
            \displaystyle -\frac{\diff{V}}{\diff{\varphi}}
        \end{bmatrix} \notag
    \end{gather}
\end{longtable} 

\noindent
Function \recttext{\texttt{find\_closest\_integer}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{double find\_closest\_integer(j);} \\
    Arguments & \texttt{double j} \\
    Description & Requantizes a given value of the angular momentum to the nearest integer, effectively rounding to the closest whole number (0, 1, 2, 3 ...). Note that the value returned as double-precision value. Using the \texttt{floor} function as the implementation results in artifact trajectories with angular momentum being brought to zero.
\end{longtable} 

\noindent
Function \recttext{\texttt{find\_closest\_half\_integer}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{double find\_closest\_half\_integer(j);} \\
    Arguments & \texttt{double j} \\
    Description & Requantizes a given value of the angular momentum to the nearest half-integer, effectively rounding to the closest value of the form (0, 1.5, 2.5, 3.5...). Note that 0.5 is skipped to represent the S-band rotational structure of the homonuclear diatomics (see Sokolov coursework).  
\end{longtable} 



\subsection{Computing averages over phase-space}


\noindent
Function \recttext{\texttt{analytic\_full\_partition\_function\_by\_V}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{double analytic\_full\_partition\_function\_by\_V(*ms, *params, Temperature)} \\
    Arguments & \texttt{MoleculeSystem *ms} \\ 
              & \texttt{double Temperature} \\
    Description & Returns analytically calculated value for the ratio of the partition function for the totality of states to the volume. {\color{red} Currently, implemented only for atom-atom, linear molecule-atom and rotor-linear molecule.}
    \begin{gather}
        [\textrm{linear molecule - atom}]: Q = 4 \pi \times \lb 2 \pi \mu k T \rb^{3/2} \times (2 \pi I k T) \notag \\
        [\textrm{rotor - linear molecule}]: Q = 32 \pi^3 \times \lb 2 \pi \mu k T \rb^{3/2} \times (2 \pi k T)^{3/2} \sqrt{I_1^\textrm{rotor} I_2^\textrm{rotor} I_3^\textrm{rotor}} \times (2 \pi I^\textrm{lin}_1 k T) \notag 
    \end{gather}
\end{longtable}

\noindent
Function \recttext{\texttt{calculate\_M0}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void calculate\_M0(*ms, *params, Temperature, *m, *q);} \\
    Arguments & \texttt{MoleculeSystem *ms} \\
              & \texttt{CalcParams *params} \\
              & \texttt{double Temperature} \\
              & \texttt{double *m} -- the estimate of $M_0$  \\
              & \texttt{double *q} -- the error of the estimate \\
    Description & By sampling from $\rho \sim e^{-K/kT}$  and rejecting some of the points using the \texttt{reject} function, \texttt{params.initialM0\_npoints} phase-points are produced to estimate $M_0$ and its error. The average over the sampled phase-points is multiplied by the \texttt{params.partial\_partition\_function\_ratio}, which is supposed to be a ratio of the partition function over the part of the phase space that is pertinent to the select pair state to the total partition function and multiplied by volume. {\color{blue} This ratio can be calculated using \texttt{mpi\_perform\_integration} function that invokes hep library.}
\end{longtable} 



\noindent
Function \recttext{\texttt{calculate\_M2}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void calculate\_M0(*ms, *params, Temperature, *m, *q);} \\
    Arguments & \texttt{MoleculeSystem *ms} \\
              & \texttt{CalcParams *params} \\
              & \texttt{double Temperature} \\
              & \texttt{double *m} -- the estimate of $M_2$  \\
              & \texttt{double *q} -- the error of the estimate \\
    Description & By sampling from $\rho \sim e^{-K/kT}$  and rejecting some of the points using the \texttt{reject} function, \texttt{params.initialM2\_npoints} phase-points are produced to estimate $M_2$ and its error. The derivative of dipole with respect to coordinates is done using cental 2-point finite-difference formula. The energy is differentiated with respect to momenta using \texttt{compute\_dHdp}. Here we use GSL's wrappers over BLAS to conduct matrix-by-vector multiplication. The average over the sampled phase-points is multiplied by the \texttt{params.partial\_partition\_function\_ratio}, which is supposed to be a ratio of the partition function over the part of the phase space that is pertinent to the select pair state to the total partition function and multiplied by volume. {\color{blue} This ratio can be calculated using \texttt{mpi\_perform\_integration} function that invokes hep library.}
\end{longtable} 

\noindent
MPI Function \recttext{\texttt{mpi\_calculate\_M0}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void calculate\_M0(*ms, *params, Temperature, *m, *q);} \\
    Arguments & \texttt{MoleculeSystem *ms} \\
              & \texttt{CalcParams *params} \\
              & \texttt{double Temperature} \\
              & \texttt{double *m} \\
              & \texttt{double *q} \\
    Description & The task of iterating \texttt{params.initialM0\_npoints} points is split equally between processes of communicator. The behavior is the same as in \texttt{calculate\_M0}.
\end{longtable} 

\noindent
MPI Function \recttext{\texttt{mpi\_calculate\_M2}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void calculate\_M2(*ms, *params, Temperature, *m, *q);} \\
    Arguments & \texttt{MoleculeSystem *ms} \\
              & \texttt{CalcParams *params} \\
              & \texttt{double Temperature} \\
              & \texttt{double *m} \\
              & \texttt{double *q} \\
    Description & The task of iterating \texttt{params.initialM2\_npoints} points is split equally between processes of communicator. The behavior is the same as in \texttt{calculate\_M2}.
\end{longtable} 

\noindent
Function \recttext{\texttt{compute\_dHdp}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}} 
    Call & \texttt{void compute\_dHdp(*ms, *dHdp);} \\
    Arguments & \texttt{MoleculeSystem *ms} \\
              & \texttt{gsl\_matrix *dHdp} \\
    Description & Calls to \texttt{rhsMonomer} to fill in derivatives of Hamiltonian with respect to momenta pertaining to monomers.
\end{longtable}

\noindent
Function \recttext{\texttt{transform\_variables}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void transform\_variables(x, *transformed, *Jac);} \\
    Arguments & \texttt{hep::mc\_point<double> const\& x} \\
              & \texttt{double *transformed} \\
              & \texttt{double *Jac} \\
    Description & Transforms a point $x$ from $n$-dimensional hypercube $[0, 1]^n$ to a point in phase-space of the \texttt{MoleculeSystem} (which is passed in using global pointer). The following transformations are implemented
    \begin{gather}
        R \leftarrow 1/x, \notag \\
        \theta \leftarrow \pi x, \notag \\
        \phi \leftarrow 2 \pi x, \notag \\
        p \leftarrow \tan(\pi (x - \sfrac{1}{2})). \notag
    \end{gather}
    %
    The jacobian of the transformation is accumulated along the steps. {\color{red} Implemented for linear molecule-atom and rotor-linear molecule pairs.}  
\end{longtable}

\noindent
Function \recttext{\texttt{integrand\_pf}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{double integrand\_pf(x);} \\
    Arguments & \texttt{hep::mc\_point<double> const\& x} \\
    Description & Based on the point in hypercube returns the value of the following integrand:
    \begin{gather}
        \textrm{jac} \cdot \exp \lb -\frac{E}{k T} \rb. \notag
    \end{gather}
    %
    (The energy is computed for \texttt{MoleculeSystem} that is passed in using global pointer.) 
\end{longtable}

\noindent
Function \recttext{\texttt{integrand\_M0}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{double integrand\_M0(x);} \\
    Arguments & \texttt{hep::mc\_point<double> const\& x} \\
    Description & Based on the point in hypercube returns the value of the following integrand:
    \begin{gather}
        \textrm{jac} \cdot \mu^2 \cdot \exp \lb -\frac{E}{k T} \rb. \notag 
    \end{gather}
    %
    (The energy is computed for \texttt{MoleculeSystem} that is passed in using global pointer. The pointer to dipole function is also assumed to be set globally.)
\end{longtable}

\noindent
Function \recttext{\texttt{integrand\_M2}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{double integrand\_M2(x);} \\
    Arguments & \texttt{hep::mc\_point<double> const\& x} \\
    Description & Based on the point in hypercube returns the value of the following integrand:
    \begin{gather}
        \textrm{jac} \cdot \Big[ \mu, H \Big] \cdot \exp \lb -\frac{E}{k T} \rb. \notag 
    \end{gather}
    %
    The derivative of dipole with respect to coordinates is computed using 2-point central finite-difference formula. (The energy is computed for \texttt{MoleculeSystem} that is passed in using global pointer. The pointer to dipole function is also assumed to be set globally.)
\end{longtable}

\noindent
Function \recttext{\texttt{mpi\_perform\_integration}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{double mpi\_perform\_integration(*ms, integrand, *params, Temperature, niterations, npoints, *m, *q);} \\
    Arguments & \texttt{MoleculeSystem *ms} \\
              & \texttt{Integrand integrand} -- \texttt{typedef double (*Integrand)(hep::mc\_point<double> const\&)}\\
              & \texttt{CalcParams *params} \\
              & \texttt{double Temperature} \\
              & \texttt{size\_t niterations} \\
              & \texttt{size\_t npoints} \\
              & \texttt{double *m} \\
              & \texttt{double *q} \\
    Description & Evaluates the integral of requested \texttt{integrand} 
\end{longtable}


\subsection{Performing averaging over trajectory ensembles}


\noindent
\recttext{\texttt{struct CalcParams}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Fields & \texttt{PairState ps} \\
           & \texttt{/* sampling */} \\
           & \texttt{double sampler\_Rmin // a.u.} \\ 
           & \texttt{double sampler\_Rmax // a.u.} \\
           & \texttt{double pesmin // Hartree} \\
           & \texttt{/* initial spectral moments check */} \\ 
           & \texttt{size\_t initialM0\_npoints} \\
           & \texttt{size\_t initialM2\_npoints} \\
           & \texttt{double partial\_partition\_function\_ratio} \\
           & \texttt{/* requantization */} \\ 
           & \texttt{size\_t torque\_cache\_len} \\
           & \texttt{double torque\_bound} \\
           & \texttt{/* trajectory */} \\
           & \texttt{double sampling\_time} \\
           & \texttt{size\_t MaxTrajectoryLength} \\
           & \texttt{bool allow\_truncating\_trajectories\_at\_length\_limit} \\
           & \texttt{double cvode\_tolerance} \\
           & \texttt{/* applicable to both correlation function AND spectral function calculations */} \\
           & \texttt{size\_t niterations} \\
           & \texttt{size\_t total\_trajectories} \\
           & \texttt{/*correlation function calculation ONLY */} \\
           & \texttt{const char *cf\_filename} \\
           & \texttt{double Rcut // distance at which the trajectory is forcefully stopped, a.u.} \\
           & \texttt{/* pr/mu calculation ONLY */} \\
           & \texttt{const char *sf\_filename} \\
           & \texttt{double ApproximateFrequencyMax // cm-1} \\
           & \texttt{double R0 // initial distance, a.u.} \\
           & \texttt{double average\_time\_between\_collisions // a.t.u.} \\
           & \texttt{/*correlation function array ONLY */} \\
           & \texttt{double* partial\_partition\_function\_ratios} \\
           & \texttt{double *satellite\_temperatures} \\
           & \texttt{size\_t num\_satellite\_temperatures} \\
           & \texttt{const char **cf\_filenames} \\
\end{longtable} 


\noindent
\recttext{\texttt{struct CFnc}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Fields & \texttt{double *t} \\
           & \texttt{double *data} \\
           & \texttt{size\_t len} -- number of samples in \texttt{*t} and \texttt{*data} \\
           & \texttt{size\_t capacity} -- capacity of \texttt{*t} and \texttt{*data} \\
           & \texttt{size\_t ntraj} -- number of trajectories used for averaging \\
           & \texttt{double Temperature} \\
           & \texttt{bool normalized} -- flag that indicates whether the data samples are normalized by \# of trajectories 
\end{longtable}

\noindent
\recttext{\texttt{struct CFncArray}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Fields & \texttt{double *t} \\
           & \texttt{double **data} \\
           & \texttt{size\_t ntemp} \\
           & \texttt{size\_t len} -- number of samples in \texttt{*t} and elements of \texttt{*data} \\
           & \texttt{double* nstar} -- number of effective trajectories at each temperature \\
           & \texttt{size\_t ntraj} - number of calculated trajectories at base temperature \\
    Description & An array of correlation functions for a fixed \texttt{base temperature} (sampling temperature) and a \texttt{satellite temperature} (target temperature for re-weighting).
\end{longtable}


\subsubsection{Calculating correlation functions}

\noindent
Function \recttext{\texttt{correlation\_eval}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{int correlation\_eval(*ms, *traj, *params, *crln, *tps);} \\
    Arguments & \texttt{MoleculeSystem *ms} \\ 
              & \texttt{Trajectory *traj} \\
              & \texttt{CalcParams *params} \\
              & \texttt{double *crln} \\
              & \texttt{int *tps} \\
    Description & Evaluates the mean between forward and backward correlation functions from the initial condition set in the \texttt{*ms}. It also tracks the number of turning points and returns it using the output parameter \texttt{*tps}.
\end{longtable} 





\noindent
MPI Function \recttext{\texttt{calculate\_correlation\_and\_save}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{CFnc calculate\_correlation\_and\_save(*ms, *params, Temperature);} \\
    Arguments & \texttt{MoleculeSystem *ms} \\ 
              & \texttt{CalcParams *params} \\
              & \texttt{double Temperature} \\
    Description & First, estimates of the zeroth and second specral moments are obtained using \texttt{params.initialM0\_npoints} and \texttt{params.initialM2\_npoints} points, respectively. The accumulation of \texttt{params.total\_trajectories} individual correlation functions is divided into \texttt{params.niterations} iterations. The individual correlation functions are obtained using \texttt{correlation\_eval} function. The current aggregate estimate of the correlation function is saved to \texttt{params.cf\_filename} at the end of each iteration. The zeroth moment based on the current estimate of the correlation function is made and compared to the value obtained during static phase-space sampling. {\color{red} NEED to correct the calculation of the estimate of the second moment based on the current correlation function}. 
    {\color{red} If \texttt{FREE\_AND\_METASTABLE} pair state is requested, then we SHOULD divide the contributions depending on the number of turning points provided by \texttt{correlation\_eval}.} The tracking of the number of turning points is already implemented. 
    The communication between processes is realized using \texttt{MPI\_Allreduce} function.  
\end{longtable} 


 
\noindent
MPI Function \recttext{\texttt{calculate\_correlation\_array\_and\_save}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{CFncArray calculate\_correlation\_array\_and\_save(*ms, *params, Temperature);} \\
    Arguments & \texttt{MoleculeSystem *ms} \\ 
              & \texttt{CalcParams *params} \\
              & \texttt{double base\_temperature} \\
    Description &  
\end{longtable} 

\noindent
Function \recttext{\texttt{save\_correlation\_function}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void save\_correlation\_function(*fp, cf, *params);} \\
    Arguments & \texttt{FILE *fp} \\
              & \texttt{CFnc cf} \\
              & \texttt{CalcParams *params} \\
    Description & The correlation function values \texttt{cf.data} assumed to be unnormalized by the number of trajectories \texttt{cf.ntraj}. The file stream \texttt{fp} is truncated using \texttt{ftruncate} before writing into it.
\end{longtable}

\noindent
Function \recttext{\texttt{invert\_momenta}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void invert\_momenta(*ms);} \\
    Arguments & \texttt{MoleculeSystem *ms} \\
    Description & Inverts the momenta stored inside MoleculeSystem. 
\end{longtable} 

\subsubsection{Calculating spectral functions}

\noindent
\recttext{\texttt{struct SFnc}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Fields & \texttt{double *nu} \\
           & \texttt{double *data} \\
           & \texttt{size\_t len} -- number of samples in \texttt{*nu} and \texttt{*data} \\
           & \texttt{size\_t capacity} -- capacity of \texttt{*nu} and \texttt{*data} \\
           & \texttt{size\_t ntraj}  -- number of trajectories used for averaging \\
           & \texttt{double Temperature}
\end{longtable}

\noindent
MPI Function \recttext{\texttt{ calculate\_spectral\_function\_using\_prmu\_representation}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{SFnc calculate\_spectral\_function\_using\_prmu\_representation\_and\_save(*ms, *params, Temperature)} \\
    Arguments & \texttt{MoleculeSystem *ms} \\ 
              & \texttt{CalcParams *params} \\
              & \texttt{double Temperature} \\
    Description & First, we check that \texttt{params.ApproximateFrequencyMax} is less than Nyquist frequency of the signal that will be sampled with requested \texttt{params.sampling\_time}. Then, based on the calculated frequency step, a length of the frequency array is calculated. Since the frequency step depends on the \texttt{params.sampling\_time} and \texttt{params.MaxTrajectoryLength}, the maximum frequency of the calculated spectral function will be somewhat close to the requested \texttt{params.ApproximateFrequencyMax} (as close as possible using the frequency step). The estimates of the zeroth and second spectral moments are obtained using \texttt{params.initialM0\_npoints} and \texttt{params.initialM2\_npoints}, respectively. The accumulation of \texttt{params.total\_trajectories} is divided into \texttt{params.niterations}. For each trajectory the intermolecular distance is set to \texttt{params.R0}. The trajectory is cut at the same distance \texttt{params.R0}. 
    Connes apodization is applied to time dependencies of Cartesian components of dipole throughout collisional trajectory before applying Fourier transform to them. The length of the dipole array which is equal to \texttt{params.MaxTrajectoryLength} needs to be a power of 2. The current estimate of the spectral function is saved to \texttt{params.sf\_filename} at the end of each iteration. The zeroth and second spectral moments are obtained from the current estimate of the spectral function and compared to the values obtained through static phase-space sampling. \\[1em]
    & When requantization is enabled, the inertia tensor value is adjusted to account for the effect of centrifugal distortion. The line position of rotational transition is given by 
    \begin{gather}
        \tilde{\nu}_{J'\leftarrow J''} = 2B(J'' + 1) - 4D(J'' + 1)^3 = 2 B_\text{eff} (J'' + 1).
    \end{gather}
    %
    The line position can be expressed in terms of the effective rotational constant, $B_\text{eff}$, which depends on the  rotational quantum number:
    \begin{gather}
        B_\text{eff} = B - 2D(J + 1)^2.
    \end{gather}
    %
    To enable the adjustment of the inertia tensor, the \texttt{DJ} field must be set, and the \texttt{MonomerType} must be either \texttt{LINEAR\_MOLECULE\_REQ\_INTEGER} or \texttt{LINEAR\_MOLECULE\_REQ\_HALFINTEGER}.
\end{longtable} 


\noindent
Function \recttext{\texttt{save\_spectral\_function}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void save\_spectral\_function(*fp, sf, *params);} \\
    Arguments & \texttt{FILE *fp} \\
              & \texttt{SFnc sf} \\
              & \texttt{CalcParams *params} \\
    Description & The spectral function values \texttt{sf.data} assumed to be unnormalized by the number of trajectories \texttt{sf.ntraj}. The file stream \texttt{fp} is truncated using \texttt{ftruncate} before writing into it.
\end{longtable}


\noindent
Function \recttext{\texttt{connes\_apodization}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void connes\_apodization(a, sampling\_time);} \\
    Arguments & \texttt{Array a} \\
              & \texttt{double sampling\_time} \\
    Description & Multiplies the provided array by Connes apodization with time-normalization factor ($a$) set to \texttt{sampling\_time}: $A(t)= (1 - t^2/a^2)^2$. See \href{https://mathworld.wolfram.com/ConnesFunction.html}{link}.
\end{longtable}


\subsection{Processing results}
\label{subsec:processing}


\noindent
Function \recttext{\texttt{read\_correlation\_function}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{bool read\_correlation\_function(*filename, *sb, *cf);} \\
    Arguments & \texttt{const char *filename} \\
              & \texttt{String\_Builder *sb} \\
              & \texttt{CFnc *cf} \\
    Description & Reads the correlation function from the file \texttt{filename} expecting a header containing metainformation (the lines should begin with \texttt{'\#'}) and data presented in the two-column format. The header is read into \texttt{String\_Builder} without parsing. The numerical values are parsed using \texttt{fscanf} function and checked to be non-NaN. Returns \texttt{false} when either the file could no be correctly opened to a parser error was encountered.  
\end{longtable}

\noindent
Function \recttext{\texttt{read\_spectral\_function}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{bool read\_spectral\_function(*filename, *sb, *sf);} \\
    Arguments & \texttt{const char *filename} \\
              & \texttt{String\_Builder *sb} \\
              & \texttt{SFnc *sf} \\
    Description & Reads the spectral function from the file \texttt{filename} expecting a header containing metainformation (the lines should begin with \texttt{'\#'}) and data presented in the two-column format. The header is read into \texttt{String\_Builder} without parsing. The numerical values are parsed using \texttt{fscanf} function and checked to be non-NaN. Returns \texttt{false} when either the file could no be correctly opened to a parser error was encountered.  
\end{longtable}

\noindent
Function \recttext{\texttt{writetxt}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{bool writetxt(*filename, *x, *y, len, *header);} \\
    Arguments & \texttt{const char *filename} \\
              & \texttt{double *x} \\
              & \texttt{double *y} \\
              & \texttt{size\_t len} \\
              & \texttt{const char *header} \\
    Description & 
\end{longtable}


\noindent
Function \recttext{\texttt{integrate\_composite\_simpson}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{double integrate\_composite\_simpson(*x, *y, len);} \\
    Arguments & \texttt{double *x} \\ 
              & \texttt{double *y} \\
              & \texttt{size\_t len} \\
    Description & Performs numerical integration using composite Simpson's 3/8 rule. See \href{https://en.wikipedia.org/wiki/Simpson%27s_rule}{link}.
\end{longtable}

\noindent
Function \recttext{\texttt{ compute\_Mn\_from\_sf\_using\_classical\_detailed\_balance}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{double compute\_Mn\_from\_sf\_using\_classical\_detailed\_balance(sf, n);} \\
    Arguments & \texttt{SFnc sf} \\
              & \texttt{size\_t n} \\
    Description & Calculates the n-th moment of the spectral function via numerical integration using the composite Simpson's rule \texttt{integrate\_composite\_simpson}. The expressions for classical detailed balance are employed. The implementation employs a straightforward application of the Simpson's rule, without invoking any special handling of lower- or higher-frequency ranges. It is assumed that the spectral function is provided solely for positive frequencies. The dimensions of the frequency and spectral function values are expected to be $\textrm{cm}^{-1}$ and $\textrm{J} \cdot \textrm{m}^6 \cdot \textrm{s}^{-1}$, respectively. The resulting spectral moment is obtained in units of $\textrm{cm}^{-n-1} \cdot \textrm{Amagat}^{-2}$.  
\end{longtable}

\noindent
Function \recttext{\texttt{ compute\_Mn\_from\_sf\_using\_quantum\_detailed\_balance}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{double compute\_Mn\_from\_sf\_using\_quantum\_detailed\_balance(sf, n);} \\
    Arguments & \texttt{SFnc sf} \\
              & \texttt{size\_t n} \\
    Description & Calculates the n-th moment of the spectral function via numerical integration using the composite Simpson's rule \texttt{integrate\_composite\_simpson}. The expressions for quantum detailed balance are employed.  The implementation employs a straightforward application of the Simpson's rule, without invoking any special handling of lower- or higher-frequency ranges. It is assumed that the spectral function is provided solely for positive frequencies. The dimensions of the frequency and spectral function values are expected to be $\textrm{cm}^{-1}$ and $\textrm{J} \cdot \textrm{m}^6 \cdot \textrm{s}^{-1}$, respectively. The resulting spectral moment is obtained in units of $\textrm{cm}^{-n-1} \cdot \textrm{Amagat}^{-2}$.  
\end{longtable}


\noindent
\recttext{\texttt{struct WingParams}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Fields & \texttt{double A} \\
           & \texttt{double B} \\
           & \texttt{double C} \\
    Description & Stores the parameters for the Lorentzian function shifted vertically by constant value: 
    \begin{gather}
        y = C + A/(1 + B^2 x^2). \notag
    \end{gather}
\end{longtable}

\noindent
\recttext{\texttt{struct WingData}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Fields & \texttt{size\_t n} \\
           & \texttt{double *t} \\
           & \texttt{double *y} \\
    Description & 
\end{longtable}

\noindent
Function \recttext{\texttt{wingmodel}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{double wingmodel(*wp, t);} \\
    Arguments & \texttt{WingParams *wp} \\
              & \texttt{double t} \\
    Description &
\end{longtable}

{\color{red} Graphical interface is needed to visualize this step...}

\noindent
Function \recttext{\texttt{fit\_baseline}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{WingParams fit\_baseline(*cf, EXT\_RANGE\_MIN);} \\
    Arguments & \texttt{CFnc *cf} \\
              & \texttt{size\_t EXT\_RANGE\_MIN} \\
    Description &
\end{longtable}

\noindent
Function \recttext{\texttt{dct}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{double* dct(*v, len);} \\
    Arguments & \texttt{double *v} \\
              & \texttt{size\_t len} \\
    Description &  Implements the Fast Discrete Cosine Transform using the trick of Makhoul (2N + half-sample shift) and FFT, also known as DCT-II. For details, see \href{https://ieeexplore.ieee.org/document/1163351}{original paper}. A new vector with result is allocated and returned. Note that the output vector is not scaled by any time/ frequency units, making the implementation unit-agnostic.
\end{longtable}

\noindent
Function \recttext{\texttt{idct}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{double* idct(*v, len);} \\
    Arguments & \texttt{double *v} \\
              & \texttt{size\_t len} \\
    Description & Implements the Inverse Fast Discrete Cosine Transform using the trick of Makhoul (2N + half-sample shift) and IFFT. For details, see \href{https://ieeexplore.ieee.org/document/1163351}{original paper}. A new vector with result is allocated and returned.
    Note that the output vector is not scaled by any time/ frequency units, making the implementation unit-agnostic.
\end{longtable}

\noindent
Function \recttext{\texttt{dct\_sf\_to\_cf(SFnc sf)}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{CFnc dct\_sf\_to\_cf(cf);} \\
    Arguments & \texttt{SFnc sf} \\
    Description &
\end{longtable}

\noindent
Function \recttext{\texttt{dct\_cf\_to\_sf(CFnc cf)}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{CFnc dct\_cf\_to\_sf(cf);} \\
    Arguments & \texttt{CFnc cf} \\
    Description &
\end{longtable}

\noindent
Function \recttext{\texttt{dct\_numeric\_sf}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{SFnc dct\_numeric\_sf(cf, *wp);} \\
    Arguments & \texttt{CFnc cf} \\
              & \texttt{WingParams *wp} \\
    Description &
\end{longtable}




\noindent
Function \recttext{\texttt{desymmetrize\_d2}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{SFnc desymmetrize\_d2(sf);} \\
    Arguments & \texttt{SFnc sf} \\
    Description & {\color{red} needs at least visual check}
\end{longtable}

\noindent
Function \recttext{\texttt{desymmetrize\_sch}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{SFnc desymmetrize\_sch(sf);} \\
    Arguments & \texttt{SFnc sf} \\
    Description &
\end{longtable}

\noindent
Function \recttext{\texttt{desymmetrize\_egf}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{SFnc desymmetrize\_egf(sf);} \\
    Arguments & \texttt{SFnc sf} \\
    Description &
\end{longtable}

\noindent
Function \recttext{\texttt{desymmetrize\_frm}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{SFnc desymmetrize\_frm(sf);} \\
    Arguments & \texttt{SFnc sf} \\
    Description &
\end{longtable}

\noindent
\recttext{\texttt{struct Spectrum}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}} 
    Fields & \texttt{double *nu} \\
           & \texttt{double *data} \\
           & \texttt{size\_t len} -- number of samples in \texttt{*nu} and \texttt{*data} \\
           & \texttt{size\_t capacity} -- capacity of \texttt{*nu} and \texttt{*data} \\
\end{longtable}

\noindent
Function \recttext{\texttt{compute\_alpha}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{Spectrum compute\_alpha(sf);} \\
    Arguments & \texttt{SFnc sf} \\
    Description & \\
\end{longtable}


\subsection{\texttt{LOESS}: locally weighted polynomial regression}
\label{subsec:loess}

LOESS blends the simplicity of linear least squares regression
with the adaptability of nonlinear regression. It achieves this by fitting simple
model to localized subset of the data, gradually constructing a function that captures 
the deterministic pattern of the variation in the data -- effectively filtering out 
the random component that follows some probability distribution.

\textbf{Degree of local polynomials}. The local polynomials fitted to each subset of the data are typically of either first
or second degree. Employing a zero-degree polynomial reduces LOESS to a weighted moving 
average. While higher-degree polynomials could theoretically be used, they are not aligned 
with the spirit of LOESS. Such polynomials are prone to overfitting within each subset and 
thus often lead to numerical instability. 

\textbf{Weight function}. The weight function, gives the most weight to the data points nearest the point of estimation and the least weight to the data points that are furthest away.
The use of the weights is based on the idea that points near each other are more likely to be related to each other in a simple way than points that are further apart.
The traditional weight function used for LOESS is the tricube weight function:
$w(x) = (1 - |x|^3)^3$ for $|x| < 1$ and 0 otherwise.
The main criteria for the weight function are the following (Cleveland, 1979):
\begin{itemize}
 \item $w(x) > 0$ for $|x| < 1$ since negative weights do not make sense
 \item $w(-x) = w(x)$: there is no reason to treat points to the left of $x$ differently from those to the right 
 \item $w(x)$ is a nonincreasing function for $x \geqslant 0$: it seems unreasonable to allow a point that is closer to x to have less weight than the one that is further
   away 
  \item $w(x) = 0$ for $|x| \geqslant 1$
\end{itemize}
%
In addition it seems desirable that $w(x)$ decrease smoothly to 0 as $x$ goes from 0
to 1. Such a weight function is more likely to produce a smoothed result. The tricube has been chosen since it enhances a $\chi^2$-distributional approximation of an estimate of the error variance. So it should provide an adequate smooth in 
many situations.
The weight for a specific point in any localized subset of data is obtained by 
evaluating the weight function at the distance between that point and the point 
of estimation, after scaling the distance so that the maximum absolute distance 
over all of the points in the subset of data is exactly one. 

Let us consider the case of local second-degree polynomials:
\begin{gather}
    \hat{y} = \beta_0 + \beta_1 x + \beta_2 x^2 \notag
\end{gather}
%
In this model, $\beta_0$, $\beta_1$, $\beta_2$ are coefficients needed to be estimated using the data pairs $(x_i, y_i)$ within a specified window. The predicted value $\hat{y}$ is derived from the this local polynomial model. 

The matrix $X$ is built using the $x$-values within the window. Each row of $X$ corresponds to a separate $x$-value, while the columns represent the constant term ($\beta_0$), the linear term ($\beta_1$), and the quadratic term ($\beta_2$).
\begin{gather}
    X = \begin{bmatrix}
        1 & x_1 & x_1^2 \\
        1 & x_2 & x_2^2 \\
        \dots & \dots & \dots \\
        1 & x_n & x_n^2 
    \end{bmatrix} \notag
\end{gather}
%
In weighted regression, each observation is assigned a weight $w_i$. These weights are organized into a digonal weight matrix $W$, defined as:
\begin{gather}
    W = \begin{bmatrix}
        w_1 & 0 & 0 & \dots \\
        0 & w_2 & 0 & \dots \\
        \dots & \dots & \dots & \dots \\
        0 & 0 & 0 & w_n
    \end{bmatrix} \notag
\end{gather}
%
The normal equations for weighted regression problem are expressed as:
\begin{gather}
    (X^T W X) \beta = X^T W y \notag
\end{gather}
%
To solve these equations we explore the following methods:
\begin{itemize}
    \item complete orthogonal decomposition of $X^T W X$ to compute its pseudo-inverse
    \item QR decomposition of $X^T W X$ (no pivoting) to compute its pseudo-inverse
    \item robust Cholesky decomposition-based solver
\end{itemize}
%
For smoothing CH$_4-$CO$_2$ spectra we hit windows consisting 10,000 points in the tail. \par


\noindent
\recttext{enum \texttt{WEIGHT\_FUNC}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Values & \texttt{WEIGHT\_TRICUBE} -- defined as $(1 - |x|^3)^3$ for $|x| < 1$ \\
           & \texttt{WEIGHT\_BISQUARE} -- defined as $(1 - |x|^2)^2$ for $|x| < 1$ \\
    Description & Enumeration defines the types of weight functions available for assigning weights to data points. The choice of weight function determines how influence is assigned to observations based on their proximity to the central point at which smoothing is performed. 
\end{longtable}

\noindent
\recttext{enum \texttt{LS\_METHOD}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Values & \texttt{LS\_COMPLETE\_ORTHOGONAL\_DECOMPOSITION} --     uses complete orthogonal decomposition to compute the pseudo-inverse of the matrix $(X^T W X)$ \\  
           & \texttt{LS\_QR\_NO\_PIVOTING} -- fastest out of variants of QR decompositions, but maybe unstable if the matrix is not rull rank \\
           & \texttt{LS\_CHOLESKY\_SOLVER} -- is usually the fastest. However, if the matrix is even mildly ill-conditioned, this is not a good method. It loses roughly twice as many digits of accuracy using the normal equation, compared to the more stable methods mentioned above. \\
    Description & Enumeration of numerical methods for solving linear least squares problem: $(X^T W X) beta = X^T W Y$ 
\end{longtable}

\noindent
Function \recttext{\texttt{loess\_init}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void loess\_init(*x, *y, len);} \\
    Arguments & \texttt{double *x} \\
              & \texttt{double *y} \\
              & \texttt{size\_t len} \\
    Description &  This function prepares the input data for LOESS by storing the predictor 'x' and response 'y' values, and setting up the necessary values for subsequent LOESS calculations. The function assumes that the input arrays `x` and `y` are of equal length and contain valid numerical data. 
\end{longtable}




\noindent
\recttext{\texttt{struct Smoothing\_Config}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Fields & \texttt{size\_t degree} -- degree of local polynomial [recommended: 2-3] \\
           & \texttt{size\_t ws\_min} -- minimum window size \\
           & \texttt{size\_t ws\_step} -- window size step \\
           & \texttt{size\_t ws\_delay} -- optional: the index at which the window is starting to increase \\
           & \texttt{size\_t ws\_cap} -- optional: cap on window size \\
\end{longtable}

\noindent
Function \recttext{\texttt{loess\_estimate}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{double loess\_estimate(x, window\_size, degree);} \\
    Arguments & \texttt{double x} \\
              & \texttt{size\_t window\_size} \\
              & \texttt{size\_t degree} \\
    Description & This function computes a local polynomial fit of provided degree within a specified window around the predictor value 'x' and uses it to estimate the response value 'y'. 
\end{longtable}


\noindent
Function \recttext{\texttt{loess\_create\_grid}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{double *loess\_create\_grid(xmin, xmax, npoints);} \\
    Arguments & \texttt{double xmin} \\
              & \texttt{double xmax} \\
              & \texttt{size\_t npoints} \\
    Description &  Generates a uniformly spaced grid of predictor values within a specified range. This function creates a grid of equally spaced 'grid\_npoints' points between `grid\_xmin` and `grid\_xmax` (inclusive). The function checks the validity of the provided grid bounds with respect to  the range of the previously provided input data for smoothing. \\
\end{longtable}


\noindent
Function \recttext{\texttt{loess\_apply\_smoothing}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{double* loess\_apply\_smoothing(*config);} \\
    Arguments & \texttt{Smoothing\_Config *config} \\
    Description & This function performs LOESS smoothing on the input data  by fitting local polynomials to subsets of the data and combining the results to produce a smoothed curve. The behavior of the smoothing process is controlled by the \texttt{Smoothing\_Config} struct, which specifies parameters such as the polynomial degree, window size, and parameters of window extension \\
\end{longtable}

\noindent
Function \recttext{\texttt{loess\_free}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void loess\_free();} \\
    Description & Releases the memory allocated for  smoothing. \\
\end{longtable}


\subsection{Functions to transform angles between frames of reference}
\label{subsec:angle-transformation}

\noindent
Function \recttext{\texttt{linear\_molecule\_atom\_lab\_to\_mol}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void linear\_molecule\_atom\_lab\_to\_mol(*qlab, *qmol);} \\
    Arguments & \texttt{double *qlab} \\
              & \texttt{double *qmol} \\
    Description & {\color{red} Put here a description from dissertation}
\end{longtable}

\noindent
Function \recttext{\texttt{linear\_molecule\_atom\_Jacobi\_mol\_by\_lab}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void linear\_molecule\_atom\_Jacobi\_mol\_by\_lab(jac, *qlab, *qmol);} \\
    Arguments & \texttt{Eigen::Ref<Eigen::MatrixXd> jac} \\
              & \texttt{double *qlab} \\
              & \texttt{double *qmol} \\
    Description & {\color{red} Put here a description from dissertation}
\end{longtable}

\noindent
Function \recttext{\texttt{CH4\_linear\_molecule\_lab\_to\_kal}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void CH4\_linear\_molecule\_lab\_to\_kal(*qlab, *qkal);} \\
    Arguments & \texttt{double *qlab} \\
              & \texttt{double *qkal} \\
    Description & {\color{red} Put here a description from dissertation}
\end{longtable}

\noindent
Function \recttext{\texttt{CH4\_linear\_molecule\_Jacobi\_kal\_by\_lab}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void CH4\_linear\_molecule\_Jacobi\_kal\_by\_lab(jac, *qlab, *qkal);} \\
    Arguments & \texttt{Eigen::Ref<Eigen::MatrixXd> jac} \\
              & \texttt{double *qlab} \\
              & \texttt{double *qkal} \\
    Description & {\color{red} Put here a description from dissertation}
\end{longtable}

\subsection{Utility structs \& functions}
\label{subsec:utility}

\noindent
\recttext{\texttt{struct Array}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Fields & \texttt{double *data} \\
           & \texttt{size\_t n} \\
    Description & Sized array in dynamic memory.
\end{longtable}

\noindent
Function \recttext{\texttt{create\_array}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{Array create\_array(n);} \\
    Arguments & \texttt{size\_t n} \\
    Description &
\end{longtable}

\noindent
Function \recttext{\texttt{init\_array}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void init\_array(n);} \\
    Arguments & \texttt{Array *a} \\
              & \texttt{double *data} \\
              & \texttt{size\_t n} \\
    Description &
\end{longtable}

\noindent
Function \recttext{\texttt{free\_array}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void free\_array(n);} \\
    Arguments & \texttt{Array *a} \\
    Description &
\end{longtable}


\noindent
\recttext{\texttt{struct String\_Builder}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Fields & \texttt{char *items} -- dynamically allocated buffer holding the string data \\
           & \texttt{size\_t count} -- the current number of characters in the buffer \\
           & \texttt{size\_t capacity} -- the total allocated capacity of the buffer in bytes \\ 
    Description & This struct represents a resizable buffer designed to build strings dynamically. It stores characters in a contiguous block of memory, allowing for manipulation of strings.
\end{longtable}

\noindent
Function \recttext{\texttt{sb\_append}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void sb\_append(*sb, *line, n);} \\
    Arguments & \texttt{String\_Builder *sb} \\
              & \texttt{const char *line} \\
              & \texttt{size\_t n} \\
    Description & Appends a sequence of characters to the \texttt{String\_Builder}. This function appends the first `n` characters from the provided `line` to the \texttt{String\_Builder}. If `n` exceeds the length of `line`, the behavior is undefined. The \texttt{String\_Builder} automatically resizes its buffer if necessary to accommodate the new characters.
\end{longtable}

\noindent
Function \recttext{\texttt{sb\_append\_cstring}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void sb\_append(*sb, *line, n);} \\
    Arguments & \texttt{String\_Builder *sb} \\
              & \texttt{const char *line} \\
    Description & This function appends a C-style (null-terminated) string \texttt{line} to the \texttt{String\_Builder}'s buffer. If the \texttt{String\_Builder} does not have sufficient capacity, its storage is automatically extended to accommodate the new content. If the \texttt{String\_Builder}'s capacity is zero, it is first resized to \texttt{INIT\_SB\_CAPACITY} bytes before any extension occurs.
\end{longtable}

\noindent
Function \recttext{\texttt{sb\_append\_format}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void sb\_append\_format(*sb, *format, ...);} \\
    Arguments & \texttt{String\_Builder *sb} \\
              & \texttt{const char *format} \\
              & \texttt{varargs(...)} \\
    Description & This function takes a format string and a variable number of arguments, formats them according to the specified format, and appends the resulting string to the provided \texttt{String\_Builder}.  If the \texttt{String\_Builder} lacks sufficient capacity, its storage is automatically extended to accommodate the new content. If the \texttt{String\_Builder}'s capacity is zero, it is first resized to \texttt{INIT\_SB\_CAPACITY} bytes before any extension occurs.
\end{longtable}

\noindent
Function \recttext{\texttt{sb\_append\_seconds\_as\_datetime\_string}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void sb\_append\_seconds\_as\_datetime\_string(*sb, s);} \\
    Arguments & \texttt{String\_Builder *sb} \\
              & \texttt{int s} \\
    Description & Appends a string representation of a time duration in seconds to a String Builder. The string is formatted as a human-readable datetime string (e.g., "1h 2m 3s"). 
\end{longtable}


\noindent
Function \recttext{\texttt{sb\_reset}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void sb\_reset(*sb);} \\
    Arguments & \texttt{String\_Builder *sb} \\
    Description & This function effectively clears the content of the \texttt{String\_Builder} by setting its length to zero. The underlying buffer is not deallocated, allowing it to be reused for subsequent operations. 
\end{longtable}


\noindent
Function \recttext{\texttt{sb\_free}} \vspace*{-0.25em}
\begin{longtable}{lp{15cm}}
    Call & \texttt{void sb\_free(*sb);} \\
    Arguments & \texttt{String\_Builder *sb} \\
    Description & This function releases the memory held by the internal buffer of the \texttt{String\_Builder} and resets the fields. 
 \end{longtable}




\noindent
\textbf{Supplied routines:}
\begin{enumerate}
    \item spherical decomposition for \textit{ab initio} PES for CO$_2-$Ar (Kalugina/Lokshtanov) 
    \item spherical decomposition for \textit{ab initio} IDS for CO$_2-$Ar (Kalugina/Lokshtanov)
    \item spherical decomposition for \textit{ab initio} PES for CH$_4-$CO$_2$ (Finenko)
    \item spherical decomposition for \textit{ab initio} IDS for CH$_4-$CO$_2$ (Finenko)
    \item spherical decomposition for \textit{ab initio} PES for H$_2-$Ar (LeRoy/Chistikov)
    \item spherical decomposition for \textit{ab initio} PES for CO$-$Ar (Pederson)
    \item spherical decomposition for \textit{ab initio} IDS for CO$-$Ar (Rizzo)
    \item PIP-NN representation for \textit{ab initio} PES surface for N$_2-$Ar (Finenko)
    \item PIP-NN representation for \textit{ab initio} IDS surface for N$_2-$Ar (Finenko)
    \item PIP-NN representation for \textit{ab initio} IDS for H$_2-$Ar (Meyer/Finenko)
\end{enumerate}

\noindent
{\textbf{Routines to be added in the future:}}
\begin{enumerate}
\item spherical decomposition for full-dimensional \textit{ab initio} PES for N$_2-$Ar (Finenko)
\item spherical decomposition for long-range IDS for N$_2-$Ar (Wang)
\item spherical decomposition for long-range $\textrm{d}\mu/\textrm{d}r$ surface for N$_2-$Ar (Wang)
\item spherical decomposition for long-range IDS for H$_2-$Ar (Kalugina)
\item spherical decomposition for \textit{ab initio} induced dipole for H$_2-$Ar (Meyer)
\item spherical decomposition for \textit{ab initio} PES for CO$_2-$CO$_2$ (Kalugina/Lokshtanov)
\item spherical decomposition for \textit{ab initio} IDS for CO$_2-$CO$_2$ (Kalugina/Lokshtanov)
\item spherical decomposition for \textit{ab initio} PES for N$_2-$N$_2$ (Karman/Chistikov)
\item spherical decomposition for \textit{ab initio} IDS for N$_2-$N$_2$ (Karman/Chistikov)
\item spherical decomposition for \textit{ab initio} PES for N$_2-$H$_2$ (Kalugina)
\item spherical decomposition for long-range IDS for N$_2-$H$_2$ (Kalugina)
\item spherical decomposition for \textit{ab initio} PES for CH$_4-$N$_2$ (Finenko)
\item spherical decomposition for \textit{ab initio} IDS for CH$_4-$N$_2$ (Finenko)
\item PIP-NN representation for full-dimensional \textit{ab initio} PES for CH$_4-$N$_2$ (Finenko)
\end{enumerate}



\section{A skeleton of the user's program}
\label{sec:user-program}

For now, let us assume that the user is supposed to use \libname as a library, not via the configuration file to a driver program (which could be arranged in the future). Then the following structure is expected:

\begin{enumerate}

\item \textbf{Initialize parallel environment} \\
Call \texttt{MPI\_Init} to initialize MPI if desired.

\item \textbf{Initialize \texttt{MoleculeSystem}} \\
Call \texttt{init\_ms} specifying types of monomers, their tensors of inertia, the reduced mass of the molecule pair and the generator seed.

\item ...

\end{enumerate}

\printbibliography[heading=bibintoc]



\section{Changelog}
\label{sec:changelog}

\begin{enumerate}
    \item [24.12.2024] \texttt{rhsMonomer}: accepts pointer so that monomer's \texttt{qp} can be changed if \texttt{apply\_requantization} flag is set.
    \item [06.01.2025] \texttt{Makefile}: switched to \texttt{Makefile} from build script.
    \item [08.01.2025] added MPI library which is hidden by the guard macro, implemented \texttt{mpi\_calculate\_M0}. Now the MPI and non-MPI versions of \texttt{hawaii.c} are compiled into two object files.  
    \item [09.01.2025] implemented \texttt{calculate\_correlation\_and\_save}. 
    \item [09.01.2025] Porting some of \texttt{hep}-functionality in \texttt{hep\_hawaii.cpp}. Zeroth moment can be calculated using adaptive Monte Carlo integration over phase space.
    \item [10.01.2025] Tracking the number of turning points is added to \texttt{correlation\_eval}.
    \item [10.01.2025] PES and its derivatives for CH$_4-$CO$_2$ are adapted.
    \item [11.01.2025] fixing error inverting momenta in \texttt{correlation\_eval}. Calculating correlation function for CO$_2-$Ar seems to be working correctly. Need to run a calculation with larger number of trajectories.
    \item [12.01.2025] added higher-order finite-difference formulas for differentiating energy: \texttt{compute\_numerical\_rhs} 
    \item [12.01.2025] trajectory for CH$_4-$CO$_2$ using kinetic energy only works correctly. Angles transformation and its jacobian needs to be adapted from FUNCHAL to account for different order of coordinates.
    \item [15.01.2025] Run calculation of correlation function for CO$_2-$Ar for 10.000.000 trajectories. The correlation function is in close agreement with the previous results. Now moving on to adapting code for processing correlation functions in \texttt{hawaii}.
    \item [17.01.2025] Adapted functions related to processing correlation function from FUNCHAL. Code implementing \texttt{loess} algorithm is left as-is because of the use of Eigen3.
    \item [19.01.2025] Added checks for NaN values of dipole in \texttt{correlation\_eval} to avoid the corruption of the correlation function estimate. At least one corrupted value of correlation function for CO$_2-$Ar  has occurred during the calculation of 10.000.000 trajectories. {\color{red} The reason for the occurence of the NaN is unknown. Should investigate when initial condition leading to NaN values is found.} Could this NaN be the consequence of overflow in \texttt{generate\_normal}?
    \item [19.01.2025] Implemented \texttt{calculate\_spectral\_function\_using\_prmu\_representation\_and\_save} function and tested that it produces correct result for CO$_2-$Ar at 300 K.
    \item [20.01.2025] Enable \texttt{switch-enum} option for compiler to invoke warning in the switch-cases where one of the cases of the enum is not explicitly handled even though default case is present. 
    \item [20.01.2025] Caught a possible (but really rare) overflow error in the implementation of Box-Mueller algorithm for sampling normally distributed variable: \texttt{generate\_normal}. 
    \item [20.01.2025] Estimate M$_0$ based on the spectral function obtained during each iteration of the pr-mu calculation
    \item [20.01.2025] Estimate M$_2$ using rejection sampling and using \texttt{hep}. Works for CO$_2-$Ar
    \item [22.01.2025] Trying out calculating correlation function for CO$-$Ar. Why is the error in M$_2$ is 13\% for 20.000.000 points? M$_0$ = $1.847 \cdot 10^{-4}$, M$_2$ = $4.148$. There was error in passing the arguments to dipole function (fixed). The correlation function "breaks" at some point during the calculation. Extremely large values (1e194) occur at approximately the same time intervals in the correlation function rendering it useless. Maybe it happens because of the PES, not because of IDS?  
    \item [25.01.2025] jacobian is working for CH$_4$-CO$_2$. \texttt{hawaii} is extended with function to compute numerical jacobian; analytical and numerical jacobians are in close agreement.
    \item [25.01.2025] fixed a bug in \texttt{extract\_q\_and\_write\_into\_ms} where coordinates for second monomer actually were overwriting the coordinates for the first monomer 
    \item [26.01.2025] adapted dipole function for CH$_4-$CO$_2$
    \item [26.01.2025] \texttt{examples/mpi\_phase\_space\_integration\_ch4\_co2} produces M$_0$ and M$_2$ spectral moments at 300 K which are consistent with previous estimations: M$_0$ =  $8.29 \cdot 10^{-4}$, M$_2$ = $5.37$. 
    \item [26.01.2025] differentiate between debug/release build in Makefile: apply separate compilation flags
    \item [27.01.2025] \texttt{examples/correlation\_ch4\_co2} produces what seems to be a correct spectrum, the spectral moments are in agreement with their phase-space counterparts.
    \item [27.01.2025] bug fix: desymmetrization procedure didn't propagate temperature to the output structure
    \item [31.01.2025] Implementing \texttt{calculate\_correlation\_array\_and\_save} that employs individual trajectory reweighting to produce results at satellite temperatures: testing on CO$_2-$Ar in \texttt{examples/correlation\_array\_co2\_ar}
    \item [01.02.2025] During the correlation and pr-mu calculations for CO$_2-$Ar on cluster, the file with temporary result is not written (at least for several iterations at the end of which the file is supposed to be written). Turns out that if stream is flushed using \texttt{fflush} and filesystem caches for a given file descriptor are forced to be committed to disk using \texttt{syncfs} the problem is resolved.
    \item [01.02.2025] \texttt{calculate\_correlation\_array\_and\_save} produces spectral profiles for CO$_2-$Ar (unbound states) that are in close agreement with the results obtained in 2021. Ensemble of approximately 8 million trajectories was used. {\color{red} Need to check for bound states as well.}
    \item [06.02.2025] CO-Ar 300K: $\text{M}_0 = 1.850 \cdot 10^{-4}$, $\text{M}_2 = 1.884$. 
    \item [08.02.2025] the factor by ALU$^3$ is moved from \texttt{save\_correlation\_function} to \texttt{correlation\_eval}. 
    \item [09.02.2025] added \texttt{normalized} flag to CFnc, changed reading/saving correlation function from/to file ({\color{red} not documented})
    \item [09.02.2025] added parsing Temperature and ntraj from header of the file using regex and added averaging of correlation functions
    \item [09.02.2025] rewrite of LOESS code to better understand what's going on there: prepare for OpenMP parallelization, check out different approaches to solve the weighted linear squares problem
    \item [09.02.2025] loess: added OpenMP parallelization of the main loop
    \item [11.02.2025] loess: refactored creating window \& added stubs for running outside OpenMP environment
    \item [12.02.2025] added checking for energy conservation inside trajectory. {\color{red} maybe need to check this info in \texttt{correlation\_eval} and discard the outlying trajectories?}
    \item [12.02.2025] implemented \texttt{average\_correlation\_functions} using vararg
    \item [12.03.2025] calculated correlation functions for He-Ar at 50K and 300K using 500mln and 300mln trajectories, respectively. At 300K we achieved a decent looking spectrum, however at 50K it still looks not converged at large frequencies. Moreover, the correlation function at 50K exhibits pulsing (beating) oscillations which result in some spectral feature at 3.5 cm-1. What is it? Is it reproducible in quantum calculation? {\color{red} It is somewhat reproduced in quantum calculation. More investigation is needed. Probably should be discussed in separate paper on He-Ar calculations with spectra provided in wide temperature range.}
    \item [16.03.2025] \texttt{hawaii}: use appropriate partial partition function for each temperature when calculating M$_0$ before proceeding to propagate trajectories
    \item [18.03.2025] Caught this mysterious error during bound states calculation for CH$_4-$CO$_2$: \texttt{[n01p012:2488401:0:2488401] Caught signal 7 (Bus error: nonexistent physical address)}. No stack trace, location of error unknown.
    \item [23.03.2025] Added functions to perform D4 and D4a desymmetrization. Some fixes included as of 26.06 (d4b file).
    \item [02.05.2025] N$_2-$Ar PIP-NN potential and dipole are added. N$_2-$Ar 300K: M$_0$ = 3.833$\cdot$10$^{-5}$, M$_2$ = 0.2321.
    \item [03.05.2025] When performing calculation of the correlation function, garbage-like values were found in the correlation accumulator. Fixed: forgot to \texttt{memset} before use. Also call to \texttt{memset} is added in \texttt{calculate\_correlation\_array\_and\_save}.
    \item [03.05.2025] Call to \texttt{MPI\_Reduce} is changed to the \texttt{MPI\_Send}/\texttt{MPI\_Recv} pair in \texttt{calculate\_correlation\_and\_save}.
    \item [14.05.2025] Applying requantization to H$_2-$Ar trajectory.
    \item [18.05.2025] Added some timestamps for HAWAII output and when saving spectral function to file in prmu-representation. Added the same timestamps for correlation function and correlation function arrays.
    \item [19.05.2025] Added PIP-NN representation of the H$_2-$Ar \textit{ab initio} induced dipole. Checked that it produces the same values as in FUNCHAL. 
    \item [19.05.2025] experimenting with the Poisson distribution for free path in prmu representation
    \item [19.05.2025] reviewed molecular constants for CO. {\color{red} Be careful with modifying molecular constants, since potential or dipole function may heavily rely on the very specific values. It's not the case for PES for CO-Ar but may easily be in other cases.}  
    \item [19.05.2025] MPI\_AllReduce $\rightarrow$ MPI\_Send/Recv for calculation using prmu representation. {\color{red} Need to check that after this change procedure produces correctly normalized results}
    \item [22.05.2025] Analytic consideration of the part of the trajectory when the linear molecule rotates freely
    \item [24.05.2025] Receive packets out-of-order from slave processes in \texttt{calculate\_spectral\_function\_using\_prmu\_representation\_and\_save}
    \item [26.05.2025] Fixed \texttt{gsl\_histogram\_extend\_right}
    \item [26.05.2025] Introduced Arena allocator and handled the extension of the histogram when received on the master process
    \item [26.05.2025] Introduced histograms of initial and final angular momenta in \texttt{calculate\_spectral\_function\_using\_prmu\_representation\_and\_save}. For now, they are printed in the output file (stdout stream). {\color{red} We need to redirect them in the corresponding files and allow to customize the path throw some variable in \texttt{CalcParams}}.
    \item [27.05.2025] Fixed a bug in the logic of turning on/off requantization in \texttt{calculate\_spectral\_function\_using\_prmu\_representation\_and\_save}. It was noticed when histogram of the number of requantization switches has become available. After the fix the intensity distribution of requantized lines in the rotational band of CO-Ar became more logical and resembling the HITRAN one.
    \item [28.05.2025] Account for the effect of centrifugal distortion when requantization is applied. The line positions of CO became in excellent agreement with those from HITRAN spectra
    \item [13.07.2025] fixed parsing error in negative floating-point numbers in \texttt{driver}
    \item [13.07.2025] fixed printing accumulated results in \texttt{mpi\_calculate\_M0}
    \item [13.07.2025] mixed spectral moments for CO-Ar at 300 K are M$_0 (\textrm{mixed}) = 5.44\cdot 10^{-5}$, M$_2 (\textrm{mixed}) = 1.46\cdot 10^{-1}$.
\end{enumerate}

\section{Todo's}

\begin{itemize}
    \item Investigate whether two-peak structure appears for He$-$Ne CIA in trajectory-based calculation using Karman PES \& IDS surfaces
    \item Investigate three-body He$-$He$-$He CIA \cite{Kowalski2014}
    \item When processing correlation function, add the Q-branch to the spectral function. I expect that part of the Q-branch is seen for CH$_4-$CO$_2$ after numerical FFT, but it's analytical part is missing. 
    \item Support N$_2$ vibration for N$_2-$Ar calculation 
    \item \texttt{mpi\_calculate\_M0}/\texttt{mpi\_calculate\_M2}: the temporary result is not accumulated over communicator, it is printed only for values accumulated only for zeroth process.
    \item log more information in the output file
    \item get rid of OpenMP magic in LOESS and instead use explicitly \texttt{pthread} library 
    \item Allow providing the value (values) of zeroth and second spectral moment to \texttt{calculate\_correlation\_and\_save} and \texttt{calculate\_correlation\_array\_and\_save}. {\color{red} For CH$_4-$CO$_2$ the calculation of second moments is time-consuming, so the values should probably be cached somehow. Honestly, calculating zeroth moments for 10+ temperatures is also no joke. It should be possible to cache these values as well.}
    \item CO$_2-$CO$_2$ in 200-300K range: communicate with Wishnow about the possibility to conduct an experiment. And write a small article about trajectory-based results?
    \item How to organize and store the calculated results for examples? The results include CFs, SFs, spectra, spectral moments and partial partition functions.
    \item We should store the results of individual iterations of \texttt{calculate\_correlation\_and\_save} and \texttt{calculate\_correlation\_array\_and\_save}. Maybe use SQL database for this?
    \item Arena Allocator for storing some temporary strings and small arrays. At the moment, there are waaaay too many mallocs/frees. 
    \item Saving the contributions of free and metastable states in correlation function separately. How can we pass in the information about the desired filenames? How to organize the storage for these contributions? 
    \item The information about the number of turning points could be saved into gsl\_histogram, and then partially displayed in the output file and saved to file system
    \item We are using MPI\_Allreduce mechanism for broadcasting. This should be changed to direct MPI\_Send / MPI\_Recv calls. {\color{red} It is changed in \texttt{calculate\_correlation\_and\_save}.}
    \item Maybe we need a check that processes in the communicator get different seeds each?
    \item In case when correlation function is calculated for bound states, we can separate the contributions for bound-bound and bound-free transitions (Fakhardji trick)
    \item Adapt transforming angles between frames of reference for linear molecule-linear molecule
    \item How to organize Makefiles for use in different environments (several clusters)? If we push the changes to remote git repo on the remote machine, the local changes get overriden, thus removing the changes made to local Makefile. Annoying... 
    \item I would like to make a graphical shell in which it will be possible to set parameters for calculation (for example, in the form of a list with available options for each parameter). The program is given paths to files (or drag-and-dropped) with potential and dipole functions and it assembles an executable file. Here I make an assumption that it is better to have the potential to be statically compiled with the rest of the code rather than dynamically loading it from library. It would probably be nice to be able to run the trajectory program from graphical shell locally and display the calculation result. If the correlation function is calculated, then there is no need to add its processing within the same "stage". Let the correlation function be calculated separately, then the result should be loaded and converted into a spectrum. In the case of calculating the spectral function in the pr-mu representation, smoothing is also required, it is also carried out in a separate "stage". This would enable us to have a starting point for a graphical shell that can demonstrate some of the features of the library without overcomplicating from the very beginning. Later on, we could think about establishing TCP connection between shell and the main program running remotely enabling the user to setup the calculation with the desired parameters and monitor the calculation. 
\end{itemize}

\section{Notes}

Usage of GNU profiler (gprof):
\begin{enumerate}
    \item Compile the program with the \texttt{-pg} flag: \texttt{g++ -pg -o test test.cpp}
    \item Run the program: \texttt{./test}
    \item Generate the profiling report: \texttt{gprof test gmon.out > analysis.txt}
\end{enumerate}



\end{document}
